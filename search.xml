<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA基础</title>
    <url>/2021/10/16/JAVA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h5 id="为什么说Java是跨平台性的语言？"><a href="#为什么说Java是跨平台性的语言？" class="headerlink" title="为什么说Java是跨平台性的语言？"></a>为什么说Java是跨平台性的语言？</h5><p>&emsp;&emsp;跨平台性是指使用Java语言编写的程序，经过一次编译后，可以在不同操作系统上运行。其原理就是Java程序是通过Java虚拟机在操作系统上运行的，只要该操作系统安装了对应的Java虚拟机，这个系统就可以运行Java程序。<br>&emsp;&emsp;也就是说，Java程序只需要跟虚拟机打交道，与操作系统的交互都由虚拟机来负责。</p>
<span id="more"></span>

<h5 id="什么是字节码-为什么Java采用字节码呢"><a href="#什么是字节码-为什么Java采用字节码呢" class="headerlink" title="什么是字节码?为什么Java采用字节码呢?"></a>什么是字节码?为什么Java采用字节码呢?</h5><p>&emsp;&emsp;字节码是Java程序经过虚拟机编译后产生的代码，该代码不是面向处理器的，而是面向虚拟机的，也就是说编译后产生的字节码需要符合虚拟机规范。<br>&emsp;&emsp;正是因为采用了字节码，所以Java在一定程度上<strong>既解决了解释型语言执行速度慢的问题，又解决了解释型语言可移植性的特点</strong>。</p>
<h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python批量修改文件后缀名</title>
    <url>/2021/10/12/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_files_list</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    实现遍历dir目录下,所有文件(包含子文件夹的文件)</span></span><br><span class="line"><span class="string">    :param dir:指定文件夹目录</span></span><br><span class="line"><span class="string">    :return:包含所有文件的列表-&gt;list</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># parent:父目录, filenames:该目录下所有文件夹,filenames:该目录下的文件名</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;E:\test&quot;</span></span><br><span class="line">filelist = get_files_list(path)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filelist:</span><br><span class="line">    portion = os.path.splitext(filename)  <span class="comment"># portion为名称和后缀分离后的列表</span></span><br><span class="line">    <span class="keyword">if</span> portion[<span class="number">1</span>] ==<span class="string">&quot;.bmp&quot;</span>:</span><br><span class="line">        newname = portion[<span class="number">0</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(filename)  <span class="comment"># 打印出要更改的文件名</span></span><br><span class="line">        os.chdir(path)</span><br><span class="line">        os.rename(filename, newname)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>跨平台性、编译型语言、解释型语言</title>
    <url>/2021/10/17/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h5 id="跨平台性是什么意思？"><a href="#跨平台性是什么意思？" class="headerlink" title="跨平台性是什么意思？"></a>跨平台性是什么意思？</h5><p>&emsp;&emsp;要知道，不同操作系统支持的函数、数据类型都可能不同，所以基于某个操作系统下编写的源代码一般是不能直接拿到另一个操作系统下编译的。注意<strong>我们所说的跨平台指的是源代码跨平台，而不是解释器跨平台</strong>。</p>
<span id="more"></span>

<h5 id="为什么说Java是跨平台性的语言？"><a href="#为什么说Java是跨平台性的语言？" class="headerlink" title="为什么说Java是跨平台性的语言？"></a>为什么说Java是跨平台性的语言？</h5><p>&emsp;&emsp;跨平台性是指使用Java语言编写的程序，经过一次编译后，可以在不同操作系统上运行。其原理就是Java程序是通过Java虚拟机在操作系统上运行的，只要该操作系统安装了对应的Java虚拟机，这个系统就可以运行Java程序。<br>&emsp;&emsp;也就是说，Java程序只需要跟虚拟机打交道，与操作系统的交互都由虚拟机来负责。</p>
<h5 id="编译型语言、解释型语言、混合型语言"><a href="#编译型语言、解释型语言、混合型语言" class="headerlink" title="编译型语言、解释型语言、混合型语言"></a>编译型语言、解释型语言、混合型语言</h5><p>&emsp;&emsp;计算机只能识别二进制指令，我们学习的Java、C++、Python都是高级语言，高级语言程序代码带运行之前要将源代码转换成二进制指令，也就是机器码，机器码是CPU可识别的硬件层面的代码。<br>&emsp;&emsp;那么，到底在何时将源代码转换成机器码呢?根据转换时机的不同，便有了不同类型的语言。</p>
<ul>
<li>编译型语言：提前将源代码通过<strong>编译器</strong>一次性全部转换成机器码，也就是生成一个可执行程序，比如windows下的.exe文件，常见的编译型语言有C、C++、Go、汇编语言<ul>
<li>优点：可以脱离开发环境运行，比如window下，通过编译后生成.exe可执行文件，可执行文件所包含的就是机器码，只要拥有了可执行程序就可以到处运行，不需要再重新编译了（不需要源代码和编译器了），可以做到<strong>一次编译，无限次运行</strong>。</li>
<li>缺点：可移植性差，因为不同操作系统的可执行文件几乎不兼容。</li>
</ul>
</li>
<li>解释型语言：通过<strong>解释器</strong>一边执行一边转换，<strong>解释型语言不会生成可执行程序</strong>，常见的解释型语言有Python、Matlab<ul>
<li>优点:可移植性好，因为有了中间层：<strong>解释器</strong>，官方针对不同操作系统开发不同的解释器，使得同样的源代码在不同操作系统下的执行结果是完全相同的。故解释型语言天生具有良好的可移植性。</li>
<li>缺点：相对编译型语言来说，解释型语言执行效率比较慢，甚至存在量级上的差距。</li>
</ul>
</li>
<li>混合型语言：半编译半解释，先将源代码转换成一种中间文件（在Java中就是字节码文件），然后再将中间文件拿到虚拟机中执行。常见的有Java、C#</li>
</ul>
<p>&emsp;&emsp;当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p>
<p>&emsp;&emsp;&emsp;&emsp;对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是<strong>闭源</strong>的。</p>
<p>&emsp;&emsp;&emsp;&emsp;对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是<strong>开源</strong>的</p>
<p>&emsp;&emsp;编译型语言和解释型语言的执行流程如下图所示：</p>
<p><img src="/2021/10/17/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/1.jpg" alt="编译型语言和解释型语言的执行流程"></p>
<p>&emsp;&emsp;有次面试被问到过<strong>Java和Python的区别</strong>，当时只答了一些语法层面，还有强类型语言弱类型语言的东西，包括垃圾回收机制（Python也是有自动垃圾回收的，而且用的是引用计数法）。面试官说我理解得不够深刻，我想他应该是想让我从这个层面来说吧。</p>
]]></content>
      <tags>
        <tag>语言类型的差异</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM复习</title>
    <url>/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="Java和C-的一个重要区别"><a href="#Java和C-的一个重要区别" class="headerlink" title="Java和C++的一个重要区别"></a>Java和C++的一个重要区别</h5><p>&emsp;&emsp;Java和C++都是面向对象的，但是C++需要程序员手动开辟(malloc)和回收(free)内存，但是有了JVM内存管理的存在，所以Java不需要程序员手动释放内存，在一定程度上减少了内存泄漏问题。</p>
<span id="more"></span>

<h5 id="为什么需要JVM？"><a href="#为什么需要JVM？" class="headerlink" title="为什么需要JVM？"></a>为什么需要JVM？</h5><p>&emsp;&emsp;Java语言最大的特点就是可移植性。也就是一次编译，到处运行。所有的程序并不是直接运行在操作系统上，而是通过JVM执行。</p>
<p>&emsp;&emsp;优点：减少了开发的难度，兼容不同操作系统。</p>
<p>&emsp;&emsp;缺点：比直接在操作系统上执行的程序的运行速度要慢。在早期这确实是一个问题，但是由于硬件技术的发展，这些问题一直在优化。</p>
<h5 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h5><p>&emsp;&emsp;JVM运行时数据区分为堆和方法区（<strong>线程共享</strong>）、虚拟机栈、本地方法栈、程序计数器（<strong>线程私有</strong>）。<img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/a.png" alt="JVM运行时数据区"></p>
<p>&emsp;&emsp;堆：内存中最大的一块，<strong>几乎</strong>所有的对象实例和数组都分配在堆中。<strong>注意是几乎，而不是全部。</strong>由于编译技术的进步，逃逸分析技术的发展，现在也存在<strong>栈上分配</strong>的情况。</p>
<p>&emsp;&emsp;方法区：用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量</strong>、即时编译器编译后的代码缓存等数据，<strong>运行时常量池也位于方法区中</strong>。</p>
<p>&emsp;&emsp;虚拟机栈：虚拟机栈的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当栈深度大于虚拟机栈所允许的深度，会抛出<strong>StackOverflowError</strong>异常。如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<strong>OutOfMemoryError</strong>异常。</p>
<p>&emsp;&emsp;本地方法栈：与虚拟机栈的作用，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的本地（Native）方法服务。</p>
<p>&emsp;&emsp;程序计数器：可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，代码的分支、循环、跳转、异常处理、线程恢复，都需要依赖这个计数器来完成。此内存区域是唯一一个在《Java虚拟机规范》中<strong>没有规定任何OutOfMemoryError</strong>情况的区域。</p>
<h5 id="new一个对象的时候会发生什么？"><a href="#new一个对象的时候会发生什么？" class="headerlink" title="new一个对象的时候会发生什么？"></a>new一个对象的时候会发生什么？</h5><p>&emsp;&emsp;Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先要执行类加载过程。也就是加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。</p>
<p>&emsp;&emsp;类加载通过后，虚拟机需要为新对象<strong>分配内存</strong>。对象的内存大小在<strong>类加载完成后就可以确定</strong>。根据内存是否规整，分配内存有两种方式。内存规整时使用指针碰撞方式，不规整时使用空闲列表方式。</p>
<p>​        &emsp;&emsp;指针碰撞：维护一个指针作为可用内存空间和不可用内存空间的分界点。内存分配就是将这个指针向着空闲内存的方向移动一段与对象内存大小相等的距离。Serial、ParNew收集器有空间压缩整理的能力（标记复制or整理算法），故这两款收集器使用指针碰撞方式来分配内存。</p>
<p>&emsp;&emsp;&emsp;&emsp;空闲列表：维护一个列表来记录哪些内存块是可用的，在分配内存时，从列表中找到一块足够大的空间划分给对象实例。CMS收集器使用的是标记清除法，理论上内存是不规整的，所以使用空闲列表的方式来分配内存。</p>
<p>&emsp;&emsp;在并发情况下，即使只是修改一个指针所指向的位置，也不一定是线程安全的。可能会出现这种情况：给对象A分配内存时，指针还没来得及修改，对象B使用了原来的指针分配内存。解决这个问题 有两种可选方案：</p>
<ul>
<li><strong>对分配内存空间的动作进行同步处理</strong>——实际上虚拟机是采用<strong>CAS+失败重试</strong>的方式保证更新操作的原子性；</li>
<li>内存分配的动作<strong>按照线程划分在不同的空间之中进行</strong>，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</li>
</ul>
<p>&emsp;&emsp;内存分配完了之后，虚拟机会为对象初始化零值。还要对对象进行必要的设置，例如类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
<h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>&emsp;&emsp;对象定位主要有两种方式：句柄访问和直接指针访问</p>
<ul>
<li>句柄访问：从堆中划分一块内存作为句柄池，reference中存放着句柄地址，句柄中存放着对象实例数据与类型数据的具体地址信息。<ul>
<li>特点：当对象被移动时，只会改变句柄池中的<strong>实例数据指针</strong>，<strong>reference本身并不需要被修改</strong>。<strong>多了一次间接访问的开销</strong><img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/c.png" alt="句柄访问对象"></li>
</ul>
</li>
<li>直接指针：<ul>
<li>速度更快，节省了一次指针定位的开销。<img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/d.png" alt="直接指针访问对象"></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
