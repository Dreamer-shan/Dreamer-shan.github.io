<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br><span id="more"></span></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>JVM 复习</title>
    <url>/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/JVM%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h5 id="Java 和 C- 的一个重要区别"><a href="#Java 和 C- 的一个重要区别" class="headerlink" title="Java 和 C++ 的一个重要区别"></a>Java 和 C++ 的一个重要区别 </h5><p>&emsp;&emsp;Java 和 C++ 都是面向对象的，但是 C++ 需要程序员手动开辟(malloc) 和回收 (free) 内存，但是有了 JVM 内存管理的存在，所以 Java 不需要程序员手动释放内存，在一定程度上减少了内存泄漏问题。<br><span id="more"></span></p>
<h5 id="为什么需要 JVM？"><a href="# 为什么需要 JVM？" class="headerlink" title="为什么需要 JVM？"></a>为什么需要 JVM？</h5><p>&emsp;&emsp;Java 语言最大的特点就是可移植性。也就是一次编译，到处运行。所有的程序并不是直接运行在操作系统上，而是通过 JVM 执行。</p>
<p>&emsp;&emsp; 优点：减少了开发的难度，兼容不同操作系统。</p>
<p>&emsp;&emsp; 缺点：比直接在操作系统上执行的程序的运行速度要慢。在早期这确实是一个问题，但是由于硬件技术的发展，这些问题一直在优化。</p>
<h5 id="JVM 运行时数据区"><a href="#JVM 运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区 </h5><p>&emsp;&emsp;JVM 运行时数据区分为堆和方法区（<strong> 线程共享 </strong>）、虚拟机栈、本地方法栈、程序计数器（<strong> 线程私有</strong>）。</p>
<p><img src="https://api2.mubu.com/v3/document_image/ed3e919c-acab-4314-9425-e357ac95a610-12259280.jpg" alt="img"></p>
<p>&emsp;&emsp; 堆：内存中最大的一块，<strong>几乎 </strong> 所有的对象实例和数组都分配在堆中。<strong>注意是几乎，而不是全部。</strong>由于编译技术的进步，逃逸分析技术的发展，现在也存在 <strong> 栈上分配 </strong> 的情况。</p>
<p>&emsp;&emsp; 方法区：用于存储已被虚拟机加载的 <strong> 类型信息、常量、静态变量 </strong>、即时编译器编译后的代码缓存等数据，<strong> 运行时常量池也位于方法区中</strong>。</p>
<p>&emsp;&emsp; 虚拟机栈：虚拟机栈的生命周期与线程相同。每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧用于存储 <strong> 局部变量表、操作数栈、动态连接、方法出口 </strong> 等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当栈深度大于虚拟机栈所允许的深度，会抛出 <strong>StackOverflowError</strong> 异常。如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 <strong>OutOfMemoryError</strong> 异常。</p>
<p>&emsp;&emsp; 本地方法栈：与虚拟机栈的作用，虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的本地（Native）方法服务。</p>
<p>&emsp;&emsp; 程序计数器：可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，代码的分支、循环、跳转、异常处理、线程恢复，都需要依赖这个计数器来完成。此内存区域是唯一一个在《Java 虚拟机规范》中 <strong> 没有规定任何 OutOfMemoryError</strong>情况的区域。</p>
<h5 id="new 一个对象的时候会发生什么？"><a href="#new 一个对象的时候会发生什么？" class="headerlink" title="new 一个对象的时候会发生什么？"></a>new 一个对象的时候会发生什么？</h5><p>&emsp;&emsp;Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先要执行类加载过程。也就是加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载。</p>
<p>&emsp;&emsp; 类加载通过后，虚拟机需要为新对象 <strong> 分配内存 </strong>。对象的内存大小在<strong> 类加载完成后就可以确定</strong>。根据内存是否规整，分配内存有两种方式。内存规整时使用指针碰撞方式，不规整时使用空闲列表方式。</p>
<p>　　指针碰撞：维护一个指针作为可用内存空间和不可用内存空间的分界点。内存分配就是将这个指针向着空闲内存的方向移动一段与对象内存大小相等的距离。Serial、ParNew 收集器有空间压缩整理的能力（标记复制 or 整理算法），故这两款收集器使用指针碰撞方式来分配内存。</p>
<p>　　空闲列表：维护一个列表来记录哪些内存块是可用的，在分配内存时，从列表中找到一块足够大的空间划分给对象实例。CMS 收集器使用的是标记清除法，理论上内存是不规整的，所以使用空闲列表的方式来分配内存。</p>
<p>&emsp;&emsp; 在并发情况下，即使只是修改一个指针所指向的位置，也不一定是线程安全的。可能会出现这种情况：给对象 A 分配内存时，指针还没来得及修改，对象 B 使用了原来的指针分配内存。解决这个问题 有两种可选方案：</p>
<ul>
<li><strong>对分配内存空间的动作进行同步处理 </strong>——实际上虚拟机是采用<strong>CAS+ 失败重试</strong> 的方式保证更新操作的原子性；</li>
<li>内存分配的动作 <strong> 按照线程划分在不同的空间之中进行 </strong>，即每个线程在 Java 堆中预先分配一小块内存，称为<strong> 本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</li>
</ul>
<p>&emsp;&emsp; 内存分配完了之后，虚拟机会为对象初始化零值。还要对对象进行必要的设置，例如类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。</p>
<h5 id="对象的访问定位"><a href="# 对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>&emsp;&emsp; 对象定位主要有两种方式：句柄访问和直接指针访问</p>
<ul>
<li>句柄访问：从堆中划分一块内存作为句柄池，reference 中存放着句柄地址，句柄中存放着对象实例数据与类型数据的具体地址信息。<ul>
<li>特点：当对象被移动时，只会改变句柄池中的 <strong> 实例数据指针 </strong>，<strong>reference 本身并不需要被修改</strong>。<strong> 多了一次间接访问的开销</strong><img src="https://api2.mubu.com/v3/document_image/c52d6c3e-b864-4b84-a834-e2e67c529c8d-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>直接指针：<ul>
<li>速度更快，节省了一次指针定位的开销。<img src="https://api2.mubu.com/v3/document_image/ce87bd80-6e3b-4ebf-95ed-11153650160d-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
<hr>
<h5 id="垃圾回收理论和垃圾回收器"><a href="# 垃圾回收理论和垃圾回收器" class="headerlink" title="垃圾回收理论和垃圾回收器"></a>垃圾回收理论和垃圾回收器</h5><p>&emsp;&emsp; 垃圾回收要考虑的三件事：哪些内存需要回收、何时回收、怎么回收</p>
<ul>
<li><strong>程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭 </strong>，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此<strong> 这几个区域的内存分配和回收都具备确定性 </strong>，在这几个区域内就不需要过多考虑如何回收的问题，<strong> 当方法结束或者线程结束时，内存自然就跟随着回收了。</strong></li>
<li>而 <strong>Java 堆和方法区</strong> 这两个区域则有着很显著的不确定性：只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，<strong>这部分内存的分配和回收是动态的。</strong></li>
</ul>
<h5 id="对象已死？"><a href="# 对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h5><p>&emsp;&emsp; 在垃圾回收之前，最先要确定的就是哪些对象还存活，哪些对象已经死去（需要回收）。判断对象是否存活主要有两种算法：引用计数法和可达性分析。</p>
<ul>
<li>引用计数法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一。当引用失效时，计数器值就减一；<ul>
<li>Python 在对象回收时就使用了引用计数法。</li>
<li>特点：原理简单，判定效率高。但是难以解决对象之间相互引用的问题（此时需要配合大量额外处理才能保证正确地工作）。</li>
</ul>
</li>
<li>可达性分析：通过 GC Roots 根对象作为起始节点集，若 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的<img src="https://api2.mubu.com/v3/document_image/917fc3c1-7a71-4570-8ecb-d6d6a0443c96-12259280.jpg" alt="img"></li>
</ul>
<h5 id="可作为 GC-Roots 的对象"><a href="# 可作为 GC-Roots 的对象" class="headerlink" title="可作为 GC Roots 的对象"></a>可作为 GC Roots 的对象</h5><ul>
<li>在 <strong> 虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 </li>
<li>在方法区中 <strong> 类静态属性引用的对象</strong>，譬如 Java 类的引用类型静态变量。</li>
<li>在方法区中 <strong> 常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</li>
</ul>
<h5 id="再谈引用"><a href="# 再谈引用" class="headerlink" title="再谈引用"></a>再谈引用 </h5><p>&emsp;&emsp; 在 JDK1.2 之前，Java 引用就是传统定义，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态未免有点过于狭隘。如果我们希望描述一类对象：当<strong> 内存空间还足够时，能保留在内存之中 </strong>，如果内存空间在进行垃圾收集后<strong> 仍然非常紧张，那就可以抛弃这些对象</strong>。</p>
<p>&emsp;&emsp; 在 JDK 1.2 版之后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用</p>
<ul>
<li>强引用：类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象</li>
<li>软引用：<strong>还有用，但非必须的对象 </strong>。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，<strong> 如果这次回收还没有足够的内存， 才会抛出内存溢出异常</strong></li>
<li>弱引用：非必须对象，但是它的强度比软引用更弱一些，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong></li>
<li>虚引用：为一个对象设置虚引用关联的 <strong> 唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</strong></li>
</ul>
<h5 id="finalize- 方法"><a href="#finalize- 方法" class="headerlink" title="finalize()方法"></a>finalize()方法 </h5><p>&emsp;&emsp; 要宣告一个对象的死亡至少要经历两次标记过程，如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。如果有必要执行 finalize()方法，那么该对象将会被放置在一个名为 F-Queue 的队列之中。稍后虚拟机会创建一个线程去筛选 F-Queue 中的对象。</p>
<p>&emsp;&emsp;finalize()方法只会执行 1 次——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this 关键字）赋值给某个类变量或者对象的成员变量。<strong>在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</strong></p>
<h5 id="回收方法区"><a href="# 回收方法区" class="headerlink" title="回收方法区"></a>回收方法区 </h5><p>&emsp;&emsp;<font color="#FF0000">  方法区实际上是有垃圾回收的。 </font> 方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量和不再使用的类型。</strong></p>
<ul>
<li>废弃常量：假如 “ABC” 在常量池中，但是现在没有任何字符串对象引用常量池中的 “ABC” 常量，如果在这时发生内存回收，这个 “ABC” 常量就将会被系统清理出常量池。<strong>常量池中其他类（接 口）、方法、字段的符号引用也与此类似。</strong></li>
</ul>
<h5 id="判定一个类型是否属于“不再被使用的类”的条件"><a href="# 判定一个类型是否属于“不再被使用的类”的条件" class="headerlink" title="判定一个类型是否属于“不再被使用的类”的条件"></a>判定一个类型是否属于“不再被使用的类”的条件 </h5><p>&emsp;&emsp; 判定一个类是否属于 <font color="red"> 不再被使用的类 </font> 需要同时满足三个条件</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h5 id="垃圾回收的几个假说 - 垃圾回收的前提 -："><a href="# 垃圾回收的几个假说 - 垃圾回收的前提 -：" class="headerlink" title="垃圾回收的几个假说 (垃圾回收的前提)："></a> 垃圾回收的几个假说(垃圾回收的前提)：</h5><ul>
<li><p>弱分代假说：绝大多数对象都是 <strong> 朝生夕灭 </strong> 的</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象就 <strong> 越难以消亡</strong></p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</p>
<p>基于前两个假说，垃圾收集器有了一下原则：</p>
<ul>
<li>收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储，也就是 <strong> 新生代和老年代</strong></li>
</ul>
<p>基于第三个假说，我们就 <strong> 不应再为了少量的跨代引用去扫描整个老年代 </strong>，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为<strong>“记忆集”</strong>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生 Minor GC 时，只有<strong> 包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描 </strong>。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但<strong> 比起收集时扫描整个老年代来说仍然是划算的</strong>。</p>
</li>
</ul>
<h5 id="标记 - 清除"><a href="# 标记 - 清除" class="headerlink" title="标记 - 清除"></a>标记 - 清除</h5><p>&emsp;&emsp; 首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。</p>
<p>&emsp;&emsp; 特点：</p>
<ul>
<li>执行效率不稳定（如果有大量对象需要回收的话，需要进行大量的标记和清除的动作）</li>
<li>会导致内存空间的碎片化问题，导致分配大对象时由于 <strong> 无法找到足够大的连续内存空间而提前触发另一次垃圾回收</strong>。</li>
</ul>
<h5 id="标记 - 复制"><a href="# 标记 - 复制" class="headerlink" title="标记 - 复制"></a>标记 - 复制</h5><p>&emsp;&emsp; 半区复制：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>&emsp;&emsp; 特点：1. 内存规整，不会产生空间碎片问题，但是如果多数对象存活，会产生大量的内存复制间的开销。2. 内存利用率低，可用内存缩小为了原来的一半。</p>
<p>&emsp;&emsp; 改进：根据新生代对象朝生夕死的特点，把新生代分为 Eden 区和 S1 区、S2 区。默认比例是 8：1：1</p>
<h5 id="标记 - 整理"><a href="# 标记 - 整理" class="headerlink" title="标记 - 整理"></a>标记 - 整理 </h5><p>&emsp;&emsp; 标记过程与标记清除一样，然后让所有存活对象<strong> 都向内存空间一端移动</strong>，再直接清理掉边界以外的内存。</p>
<p>&emsp;&emsp; 标记整理和标记清除的区别在于，标记整理是 <strong> 移动式回收算法 </strong>，标记清理是非移动式算法。对象移动操作必须<font color="red"> 全程暂停用户应用程序 </font> 才能进行，也就是 STW</p>
<h5 id="并发的可达性分析"><a href="# 并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析 </h5><p>&emsp;&emsp; 两种后果：收集器在对象图上标记颜色时，用户线程可能在修改引用关系，导致错误的 GC。<strong> 把原本消亡的对象标记为存活（问题不大，下次收集清理掉就好）或者把存活的对象标记为已消亡（非常致命）</strong></p>
<p>&emsp;&emsp; 解决方案：增量更新和内存快照</p>
<ul>
<li><p>增量更新：当黑色对象插入新的指向白色对象的引用关系时，就 <strong> 将这个新插入的引用记录下来 </strong>，等并发扫描结束之后，再<strong> 将这些记录过的引用关系中的黑色对象为根，重新扫描一次</strong>。</p>
</li>
<li><p>内存快照：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<p>CMS 是基于增量更新来做 <strong> 并发标记 </strong> 的，G1、Shenandoah 则是用原始快照来实现。</p>
</li>
</ul>
<h5 id="经典垃圾收集器"><a href="# 经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器 </h5><h6 id="emsp-CMS（标记 - 清除算法）"><a href="#emsp-CMS（标记 - 清除算法）" class="headerlink" title="&emsp;CMS（标记 - 清除算法）"></a>&emsp;CMS（标记 - 清除算法）</h6><p>&emsp;&emsp; 老年代<strong> 并行收集器 </strong>，以获取最短回收停顿时间为目标的收集器，具有<strong> 高并发、低停顿 </strong> 的特点，追求最短 GC 回收停顿时间<img src="https://api2.mubu.com/v3/document_image/27cc5986-593c-4797-bca5-8eb0d89b53f5-12259280.jpg" alt="img"></p>
<p>&emsp;&emsp;    回收步骤:</p>
<ul>
<li><p>初始标记: 只是标记一下 GC Roots 能直接关联到的对象，速度很快，<strong>需要 STW</strong></p>
</li>
<li><p>并发标记：进行 GC Roots Tracing 的过程，<strong>在整个过程中耗时最长</strong>。</p>
</li>
<li><p>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记 <strong> 产生变动的那一部分对象的标记记录 </strong>，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段<strong> 也需要 STW</strong></p>
</li>
<li><p>并发清除（CMS concurrent sweep）</p>
</li>
<li><p>优点：并发收集、低停顿</p>
</li>
<li><p>缺点：<strong>无法处理浮动垃圾、标记清除算法带来的空间碎片</strong></p>
<ul>
<li><strong>标记 - 清除算法导致的空间碎片</strong>： CMS 收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。</li>
<li><strong>浮动垃圾：</strong>由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS 无法再当次收集中处理掉它们，只好留待下一次 GC 时再清理掉。</li>
<li>解决方案：<strong>标记整理算法，也就是配合 ParNew 收集器</strong><ul>
<li>为了解决空间碎片问题，CMS 收集器提供了一个 -XX：+UseCMS-CompactAtFullCollection 开关参数（默认是开启的，此参数从 JDK 9 开始废弃），用于在 CMS 收集器不得不进行 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在 Shenandoah 和 ZGC 出现前）是无法并发的。这样空间碎片问题是解决了，但停顿时间又会变长，因此虚拟机设计者们还提供了另外一个参数 -XX：CMSFullGCsBeforeCompaction（此参数从 JDK 9 开始废弃），<strong>这个参数的作用是要求 CMS 收集器在执行过若干次（数量由参数值决定）不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为 0，表示每次进入 Full GC 时都进行碎片整理）。</strong></li>
</ul>
</li>
</ul>
<h6 id="G1 收集器（标记 - 整理，不会产生内存空间碎片问题）"><a href="#G1 收集器（标记 - 整理，不会产生内存空间碎片问题）" class="headerlink" title="G1 收集器（标记 - 整理，不会产生内存空间碎片问题）"></a>G1 收集器（标记 - 整理，不会产生内存空间碎片问题）</h6><p>&emsp;Java 堆并行收集器，G1 收集器不同于之前的收集器的一个重要特点是：G1<strong>回收的范围是整个 Java 堆</strong>(包括新生代，老年代)，而其他收集器仅限于新生代或老年代。</p>
<p>&emsp; 回收步骤跟 CMS 大概相似，注意，<strong>最终标记阶段处理的是原始快照记录。</strong></p>
<ul>
<li>特点：<ul>
<li>优点：G1 从 <strong> 整体来看是基于“标记 - 整理”算法 </strong> 实现的收集器，但从 <strong> 局部 </strong>（两个 Region 之间）上看又是<strong> 基于“标记 - 复制”算法 </strong> 实现，这两种算法都意味着 G1 运作期间 <strong> 不会产生内存空间碎片</strong></li>
<li>缺点：巨型区域（Humongous Region）用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。<strong>为了能找到连续的 H 区，有时候不得不启动 Full GC</strong>。 虽然 G1 和 CMS 都使用卡表来处理跨代指针，<strong>但 G1 的卡表实现更为复杂</strong></li>
</ul>
</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/ff1e23ec-c0da-42ae-aee9-861e9bef469f-12259280.jpg" alt="img"></p>
</li>
</ul>
<h6 id="3-6-2-ZGC 收集器"><a href="#3-6-2-ZGC 收集器" class="headerlink" title="3.6.2 ZGC 收集器"></a>3.6.2 ZGC 收集器</h6><ul>
<li><p>ZGC 也采用基于 Region 的堆内存布局，但与它们不同的是，ZGC 的 Region 可以具有大、中、小三类容量</p>
</li>
<li><p>核心：并发整理算法</p>
<ul>
<li><p>染色指针技术，一种直接将少量额外的信息存储在指针上的技术</p>
</li>
<li><p>从前，如果我们要在对象上存储一些额外的、只供收集器或者虚拟机本身使用的数据，通常会在对象头中增加额外的存储字段，如对象的哈希码、分代年龄、锁记录等就是这样存储的</p>
</li>
</ul>
</li>
</ul>
<h5 id="内存分配策略"><a href="# 内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul>
<li><p>虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<ul>
<li><p>对象优先在 Eden 区分配，当 Eden 区没有足够空间进行分配时，虚拟机将发起 一次 Minor GC</p>
</li>
<li><p>大对象直接进入老年代：复制对象时，大对象就意味着高额的内存复制开销。HotSpot 虚拟机提供了 -XX：PretenureSizeThreshold 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是 <strong> 避免在 Eden 区及两个 Survivor 区之间来回复制，产生大量的内存复制操作。</strong></p>
</li>
<li><p>长期存活对象将进入老年代：CMS 默认值位 15，G1 为 6</p>
</li>
</ul>
</li>
</ul>
<h5 id="动态对象年龄判定"><a href="# 动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定 </h5><p>&emsp; 并不要求对象的年龄必须得到某个阈值才能晋升老年代，如果在 Survivor 空间中<strong> 相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</strong>，无须等到 -XX： MaxTenuringThreshold 中要求的年龄。</p>
<h5 id="空间分配担保"><a href="# 空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h5><ul>
<li>如果另外一块 Survivor 空间 <strong> 没有足够空间存放上一次新生代收集下来的存活对象</strong>，这些对象便将通过分配担保机制直接进入老年代</li>
<li>在发生 Minor GC 之前，虚拟机必须先 <strong> 检查老年代最大可用的连续空间是否大于新生代所有对象总空间 </strong>，如果成立，那这一次 Minor GC 可以确保是安全的。如果不成立，虚拟机会先查看 HandlePromotionFailure 参数的设置值<strong> 是否允许担保失败 </strong>（Handle Promotion Failure）；如果允许，那会继续检查<strong> 老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的 </strong>；如果小于，或者 -XX：HandlePromotionFailure 设置<strong> 不允许冒险，那这时就要改为进行一次 Full GC。</strong></li>
<li>“冒险”是冒了什么风险：前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个 Survivor 空间来作为轮换备份，因此当出现大量对象在 Minor GC 后仍然存活的情况——<strong>最极端的情况就是内存回收后新生代中所有对象都存活 </strong>，需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代，<strong> 但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值。如果赌赢了，就只需要 Minor GC，赌输了还是需要 Full GC，这样停顿时间就很长了</strong>。</li>
</ul>
<h5 id="类加载机制"><a href="# 类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h5><p>&emsp; 类的生命周期：加载、验证、准备、解析、初始化、使用和卸载<img src="https://api2.mubu.com/v3/document_image/7b7fd4c0-2228-481a-b2db-7c796db28dad-12259280.jpg" alt="img"></p>
<h6 id="类加载过程"><a href="# 类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h6><ul>
<li>加载：根据查找路径找到相应的 class 文件然后导入；</li>
<li>验证：检查加载的 class 文件的正确性(文件格式验证、元数据验证、字节码验证)</li>
<li>准备：正式为 <strong> 类中定义的变量（即静态变量）</strong>分配内存并 <strong> 设置类变量初始值</strong>。</li>
<li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li>
<li>初始化：对静态变量和静态代码块执行初始化工作</li>
</ul>
<h6 id="双亲委派模型"><a href="# 双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型 </h6><p>&emsp; 如果一个类加载器收到了类加载的请求，它首先<strong> 不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成 </strong>，每一个层次的类加载器都是如此，因此所有的<strong> 加载请求最终都应该传送到最顶层的启动类加载器中</strong>，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p>&emsp; 好处：是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<p><img src="https://api2.mubu.com/v3/document_image/36cb3d78-4a3d-4f20-8623-4428282459e5-12259280.jpg" alt="img"></p>
<h5 id="类加载的时机（什么时候会对类进行初始化）"><a href="# 类加载的时机（什么时候会对类进行初始化）" class="headerlink" title="类加载的时机（什么时候会对类进行初始化）"></a>类加载的时机（什么时候会对类进行初始化）</h5><ul>
<li>遇到 new 关键字</li>
<li>读取类中的 <strong> 静态字段 </strong> 或者调用类中的 <strong> 静态方法 </strong> 的时候</li>
<li>初始化类的时候如果发现其父类还没初始化，那么 <strong> 先触发其父类的初始化</strong></li>
<li>虚拟机启动时，用户需要制定一个执行的主类 也就是包含 main 方法的类，虚拟机会先初始化这个类</li>
</ul>
<h5 id="泛型"><a href="# 泛型" class="headerlink" title="泛型"></a>泛型 </h5><p>&emsp;<font color="red"> 泛型的本质是参数化类型或者参数化多态的应用，</font>泛型让程序员能够针对泛化的数据类型编写同样的算法，增强了编程语言的抽象能力。</p>
<h6 id="Java 与 C- 的泛型"><a href="#Java 与 C- 的泛型" class="headerlink" title="Java 与 C#的泛型"></a>Java 与 C# 的泛型 </h6><p>&emsp;Java 选择的泛型实现方式叫作<font color="red"> 类型擦除式泛型 </font>，而 C# 选择的泛型实现方式是<font color="red"> 具现化式泛型</font>。</p>
<p>&emsp;C# 里面泛型无论在程序源码里面还是编译后的中间语言表示里面，List<string<String>&gt; 与 List<int<int>&gt; 就是两个不同的类型，它们 <strong> 由系统在运行期生成，有着自己独立的虚方法表和类型数据</strong>。 </int<int></string<String></p>
<p>&emsp; 而 Java 语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被 <strong> 替换为原来的裸类型（裸类型应被视为所有该类型泛型化实例的共同父类型）</strong>了，并且在相应的地方插入了强制转型代码，因此 <strong> 对于运行期的 Java 语言来说，ArrayList<int<int>&gt; 与 ArrayList<string<string>&gt; 其实是同一个类型</string<string></int<int></strong></p>
<p>&emsp;Java 的类型擦除式泛型无论在使用效果上还是运行效率上，几乎是全面落后于 C# 的具现化式泛型，而它的 <strong> 唯一优势 </strong> 是在于实现这种泛型的影响范围上：<strong>擦除式泛型的实现 </strong> 几乎只需要在 Javac 编译器上做出改进即可，<strong>不需要改动字节码、不需要改动 Java 虚拟机</strong>。</p>
<h5 id="后端编译与优化"><a href="# 后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h5><h6 id="emsp- 编译器和解释器"><a href="#emsp- 编译器和解释器" class="headerlink" title="&emsp; 编译器和解释器"></a>&emsp; 编译器和解释器</h6><p>&emsp;&emsp; 主流的 Java 虚拟机内部都同时包含解释器和编译器，所以说<strong>Java 是半编译半解释的语言</strong>。</p>
<p>&emsp;&emsp; 编译器和解释器的优势</p>
<ul>
<li><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即运行。</p>
</li>
<li><p>当程序启动后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，这样可以减少解释器的中间损耗，获得更高的执行效率。</p>
</li>
<li><p>当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</p>
<p><img src="https://api2.mubu.com/v3/document_image/6efef1b2-4243-4001-a783-7de526ec7691-12259280.jpg" alt="img"></p>
</li>
</ul>
<h6 id="方法内联"><a href="# 方法内联" class="headerlink" title="方法内联"></a>方法内联 </h6><p>　其主要目的有两个：一是去除方法调用的成本（如查找方法版本、建立栈帧等）；二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。因此各种编译器一般都会把内联优化放在<strong> 优化序列最靠前的位置<img src="https://api2.mubu.com/v3/document_image/7091d500-ea40-48b0-845d-53a8216706da-12259280.jpg" alt="img"></strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/ad4a1aab-b2be-4ac5-86e6-3ecb183eb6e9-12259280.jpg" alt="img"></p>
<h6 id="冗余访问消除"><a href="# 冗余访问消除" class="headerlink" title="冗余访问消除"></a>冗余访问消除</h6><p>　假设代码中间注释掉的“…dostuff…”所代表的操作不会改变 b.value 的值，那么就可以把“z=b.value”替换为“z=y”，因为上一句“y=b.value”已经保证了变量 y 与 b.value 是一致的，这样就可以不再去访问对象 b 的局部变量了</p>
<p><img src="https://api2.mubu.com/v3/document_image/988ec2a3-f5d6-4803-8e98-ad514a78c448-12259280.jpg" alt="img"></p>
<h6 id="复写传播"><a href="# 复写传播" class="headerlink" title="复写传播"></a>复写传播</h6><p>　这段程序的逻辑之中没有必要使用一个额外的变量 z，它与变量 y 是完全相等的，因此我们可以使用 y 来代替 z</p>
<p><img src="https://api2.mubu.com/v3/document_image/c136d4f6-5ef1-45f0-909b-79232a10d079-12259280.jpg" alt="img"></p>
<h6 id="无用代码消除"><a href="# 无用代码消除" class="headerlink" title="无用代码消除"></a>无用代码消除</h6><p>　无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。因此它又被很形象地称为“Dead Code”，在上图中，“y=y”是没有意义的</p>
<p><img src="https://api2.mubu.com/v3/document_image/900bd114-cfb8-4948-a3f8-f33cafda6b3e-12259280.jpg" alt="img"></p>
<h5 id="优化技术"><a href="# 优化技术" class="headerlink" title="优化技术"></a>优化技术</h5><h6 id="方法内联 -1"><a href="# 方法内联 -1" class="headerlink" title="方法内联"></a>　方法内联</h6><p>　就是把目标方法的代码原封不动地“复制”到发起调用的方法之中，避免发生真实的方法调用而已</p>
<h6 id="逃逸分析"><a href="# 逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析 </h6><p>　分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，<strong> 例如作为调用参数传递到其他方法中，这种称为方法逃逸</strong>；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</p>
<p>　<strong>如果能证明一个对象不会逃逸到方法或线程之外 </strong>（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例<strong> 采取不同程度的优化</strong>，如：</p>
<ul>
<li>栈上分配：一般情况下，在 Java 虚拟机中是在堆上分配创建对象的内存空间，GC 时会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。<strong>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。</strong>在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那 <strong> 大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多</strong>。栈上分配可以支持方法逃逸，但不能支持线程逃逸。</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础</title>
    <url>/2021/11/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h5 id="Java 基础"><a href="#Java 基础" class="headerlink" title="Java 基础"></a>Java 基础</h5><h6 id="Java 基本数据类型"><a href="#Java 基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h6><ul>
<li>整型：byte、short、long、int</li>
<li>浮点型：单精度浮点型 float、双精度浮点型 double</li>
<li>字符型：char</li>
</ul>
<p>注意，<font color="red"><code>String</code>不是基本数据类型</font>。</p>
<span id="more"></span>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>占用内存</th>
<th>成员变量默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1B</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>2B</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>4B</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>8B</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>4B</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>8B</td>
<td>0.0D</td>
</tr>
<tr>
<td>boolean</td>
<td>1B</td>
<td>false</td>
</tr>
</tbody>
</table>
</div>
<h6 id="单精度浮点型和双精度浮点型的区别"><a href="# 单精度浮点型和双精度浮点型的区别" class="headerlink" title="单精度浮点型和双精度浮点型的区别"></a>单精度浮点型和双精度浮点型的区别</h6><p>　单精度（float），一般在计算机中存储占用 4 字节，双精度（double）在计算机中存储占用 8 字节，由于位数存储位不同，他们能表示的数值的范围就不同，也就是能准确表示的数的位数就不同</p>
<h6 id="final 关键字"><a href="#final 关键字" class="headerlink" title="final 关键字"></a>final 关键字</h6><ul>
<li>被 final 修饰的类不可以被继承</li>
<li>被 final 修饰的方法不可以被重写</li>
<li>被 final 修饰的变量不可以被改变，被 final 修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li>
</ul>
<h6 id="static 关键字"><a href="#static 关键字" class="headerlink" title="static 关键字"></a>static 关键字 </h6><p>　1. 创建独立于具体对象的域变量或者方法：<strong> 即使没有创建对象，也能使用属性和调用方法 </strong>，可以通过类名.(字段) 或者类名.(方法)调用</p>
<p>　2. 优化程序性能：类被加载的时候，会按照 static 块的顺序来执行每个 static 块，<strong>只会执行一次 </strong>，因此一些<strong> 只需要进行一次的初始化操作 </strong> 都放在 static 代码块中进行。</p>
<p>　注意事项：1、静态只能访问静态。 2、非静态既可以访问非静态的，也可以访问静态的。</p>
<h6 id="为什么静态方法（变量）只能调用静态方法（变量），不能调用非静态方法？"><a href="# 为什么静态方法（变量）只能调用静态方法（变量），不能调用非静态方法？" class="headerlink" title="为什么静态方法（变量）只能调用静态方法（变量），不能调用非静态方法？"></a>为什么静态方法（变量）只能调用静态方法（变量），不能调用非静态方法？</h6><p>　被 static 修饰的变量或者方法 <strong> 是优先于对象存在的 </strong>，也就是说当一个类加载完毕之后，<strong> 即便没有创建对象，也可以去访问 </strong>。如果静态方法去访问非静态方法，可能<strong> 此时非静态方法所处的类还没有被实例化，如果这个时候访问就会出错</strong>。</p>
<h6 id="抽象类和接口对比"><a href="# 抽象类和接口对比" class="headerlink" title="抽象类和接口对比"></a>抽象类和接口对比 </h6><p>　抽象类是用来捕捉子类的共性的，接口是抽象方法的集合。它们都<strong> 不能被实例化，都包含抽象方法。</strong></p>
<p>　使用场景：</p>
<ul>
<li><p>行为模型应该通过接口而不是抽象类定义，所以通常 <strong> 优先选用接口，尽量少用抽象类</strong>。</p>
</li>
<li><p>选择抽象类的时候通常是如下情况：<strong>需要定义子类的行为，又要为子类提供通用的功能</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/77fbbce7-4bd4-47d4-9030-da75c687bb35-12259280.jpg" alt="img"></p>
</li>
</ul>
<h6 id="对象实例与对象引用有何不同？"><a href="# 对象实例与对象引用有何不同？" class="headerlink" title="对象实例与对象引用有何不同？"></a>对象实例与对象引用有何不同？</h6><p>　对象实例在 <strong> 堆内存 </strong> 中，对象引用在 <strong> 栈内存 </strong> 中。一个对象引用可以指向 0 或者 1 个对象（１个指针最多指向１个对象），但是１个对象实例可能有多个引用指向它（１个对象可能有多个指针同时指向它）</p>
<h6 id="重写与重载"><a href="# 重写与重载" class="headerlink" title="重写与重载"></a>重写与重载 </h6><p>　方法的重载和重写<strong> 都是实现多态的方式 </strong>，区别在于前者实现的是<strong> 编译时的多态性 </strong>，而后者实现的是<strong> 运行时的多态性 </strong>。多态的三个条件：1. 继承关系　2. 子类重写父类的方法　3. 父类引用指向子类对象（<strong> 左父右子</strong>）</p>
<p>　重载：发生在同一个类中，方法名相同参数列表不同或者顺序不同</p>
<p>　重写：发生在父子类中，方法名、参数列表必须相同。抛出的异常 <strong> 小于等于 </strong> 父类，访问修饰符 <strong> 大于等于 </strong> 父类</p>
<h6 id="和 equals 方法"><a href="# 和 equals 方法" class="headerlink" title="== 和 equals 方法"></a>== 和 equals 方法 </h6><p>　==：判断地址是否相等，<strong> 基本类型比较的是值，引用类型比较的是地址</strong>。</p>
<p>　equals：如果没有重写 equals() 方法，等价于’==’，一般都会重写 equals() 方法来判断，若两个对象的内容相等，则返回 true</p>
<p>　注意：String 中的 equals 方法是被重写过的，<strong>因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值</strong></p>
<h6 id="为什么要用 hashcode？"><a href="# 为什么要用 hashcode？" class="headerlink" title="为什么要用 hashcode？"></a>为什么要用 hashcode？</h6><p>　把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，判断 <strong> 是否发生了哈希冲突 </strong>，如果发生了哈希冲突，这时会<strong> 调用 equals()方法来检查 hashcode 相等的对象是否真的相同</strong>。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。就大大减少了 equals 的次数。</p>
<h5 id="反射"><a href="# 反射" class="headerlink" title="反射"></a>反射 </h5><h6 id="什么是反射"><a href="# 什么是反射" class="headerlink" title="什么是反射"></a> 什么是反射</h6><p>　在运行状态中，对于任意一个类（对象），都能够知道这个类（对象）的所有属性和方法；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制</p>
<h6 id="获取反射的三种方式"><a href="# 获取反射的三种方式" class="headerlink" title="获取反射的三种方式"></a>获取反射的三种方式</h6><p>　1. 类名.class   2.  实例对象.getClass  3.Class.forName(“全限定名”)</p>
<h6 id="反射的应用场景"><a href="# 反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景 </h6><p>　动态代理、Spring 通过 xml 文件装载 Bean、使用 JDBC 连接数据库时 Class.forName() 通过反射加载数据库的驱动程序</p>
<h5 id="string 为什么不可变"><a href="#string 为什么不可变" class="headerlink" title="string 为什么不可变"></a>string 为什么不可变 </h5><p> 在 JDK1.8 中，String 的源码如下，可以看到 String 类本身和字符数组 value 都是使用 final 修饰的，所以 String 类是不能被继承的，字符数组是不能改变的。</p>
<p><img src="https://api2.mubu.com/v3/document_image/d915c05d-ed12-4dc5-9f39-7351894f03f6-12259280.jpg" alt="img"></p>
<p>注意：</p>
<ol>
<li>String 不可变但不代表引用不可以变，s1 的内容是不变的，但是指向地址变了，原来指向 <code>aaa</code> 的内存地址，现在指向 <code>aaabbb</code> 的内存地址</li>
<li>通过 <strong> 反射可以暴力修改</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">s1 = s1 + <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s1);</span><br><span class="line">输出： aaabbb</span><br></pre></td></tr></table></figure>
<h5 id="String-str-”i”与 -String-str-new-String-“i”- 有什么区别？"><a href="#String-str-”i”与 -String-str-new-String-“i”- 有什么区别？" class="headerlink" title="String str=”i”与 String str=new String(“i”)有什么区别？"></a>String str=”i”与 String str=new String(“i”)有什么区别？</h5><p>　他们的内存分配方式不一样。<code>String str=&quot;i&quot;</code>，虚拟机会将其分配到字符串常量池中；而 <code>String str=new String(“i”)</code>会被分到堆内存中。</p>
<h5 id="string 有哪些特性？"><a href="#string 有哪些特性？" class="headerlink" title="string 有哪些特性？"></a>string 有哪些特性？</h5><p>　1. 不变性：字符串是不可变的，所以也是 <font color="red"> 线程安全 </font> 的。对字符串所有的操作，实际上都是创建一个新的对象，再把引用指向该对象。</p>
<p>　2. 常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用，提高访问速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;shy&quot;</span>; <span class="comment">//s1 指向常量池</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;shy&quot;</span>);  <span class="comment">//s2 指向堆上的对象</span></span><br><span class="line">String s3 = <span class="string">&quot;shy&quot;</span>;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="string">&quot;shy&quot;</span>);</span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true 重写 equals 方法 比较的是字符串的值</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false == 比较的是地址,s1 和 s2 地址不同</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true 常量池优化,s3 不会开辟新的内存空间</span></span><br><span class="line">System.out.println(s2 == s4); <span class="comment">//false s2 和 s4 是两个对象</span></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;shy&quot;</span>); <span class="comment">//false  s2 是堆内存中的对象,shy 在字符串常量池中, 内存地址不一样</span></span><br><span class="line">s2 = s1;    <span class="comment">// 改变 s2 的指向, 让 s2 指向常量池</span></span><br><span class="line">System.out.println(s2 == <span class="string">&quot;shy&quot;</span>); <span class="comment">//true  s2 指向常量池</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 实战</title>
    <url>/2021/10/20/JVM%E5%AE%9E%E6%88%98/JVM%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>JVM 实战</p>
<span id="more"></span>
<ul>
<li><p>jps 命令   jps 是 jdk 提供的一个查看当前 java 进程的小工具，列出了现在运行的线程情况</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/a4232929-3de1-4da8-a98d-8aece0f929e9-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>查看 VM 参数  jinfo 命令可以用来查看 Java 进程运行的 JVM 参数</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/c37307cd-e977-4803-880c-1ce4ad63e4d6-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>具体查看某个参数  </p>
<ul>
<li>jinfo -flag MetaspaceSize(参数名) 55504(pid 号)<ul>
<li><img src="https://api2.mubu.com/v3/document_image/5e2afc97-0a8a-4c34-a052-53e88318f3f5-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>常用参数</p>
<ul>
<li>-Xms600m 堆空间（年轻代 + 老年代）的 <strong> 初始内存 </strong> 大小</li>
<li>-Xmx600m 堆空间（年轻代 + 老年代）的 <strong> 最大内存 </strong> 大小</li>
<li>开发中建议将初始堆内存和最大的堆内存设置成相同的值。</li>
<li>-XX:NewRatio ： 设置新生代与老年代的比例。默认值是 2.(一般不会调)  除非我们知道 <strong> 很多类对象生命周期非常长，在某些情况下还能与 JVM 的生命周期保持一致</strong></li>
<li><em>-</em>XX:SurvivorRatio ：设置新生代中 Eden 区与 Survivor 区的比例。默认值是 8</li>
</ul>
</li>
<li><p>为什么需要分代？不分代就不能正常工作了吗？</p>
<ul>
<li>经研究，不同对象的生命周期不同。70%-99% 的对象都是临时对象。<ul>
<li>新生代：有 Eden、Survivor 构成（s0,s1 又称为 from to），to 总为空</li>
<li>老年代：存放新生代中经历多次依然存活的对象</li>
</ul>
</li>
<li><strong>其实不分代完全可以，分代的唯一理由就是优化 GC 性能 </strong>。如果没有分代，<strong> 那所有的对象都在一块 </strong>，就如同把一个学校的人都关在一个教室。<strong>GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描</strong>，而很多对象都是朝生夕死的，<strong> 如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</strong></li>
</ul>
</li>
<li><p>大对象直接进入老年代：分配 60m 堆空间，新生代 20m ，Eden 16m， s0 2m， s1 2m，buffer 对象 20m，Eden 区无法存放 buffer， 直接晋升老年代</p>
<ul>
<li><em>-Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</em><ul>
<li><img src="https://api2.mubu.com/v3/document_image/955732eb-5ae9-43b5-8a40-5e84472cc8d5-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/bd05e07c-8d9a-40c9-8d6f-0bc64d9b0408-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>什么是 TLAB</p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f5ff4ad1-cd53-4197-bc3d-5baf37b2c2d6-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为 <strong> 快速分配策略</strong></li>
</ul>
</li>
<li><p>说明</p>
<ul>
<li>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 明确是是将 TLAB 作为内存分配的首选</li>
<li>jinfo -flag UseTLAB 42668<ul>
<li><img src="https://api2.mubu.com/v3/document_image/af22140d-65df-4c86-89c9-2f3cc9bb0f4e-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>在程序中，开发人员可以通过选项“-XX:UseTLAB“ 设置是够开启 TLAB 空间</li>
<li>默认情况下，TLAB 空间的内存非常小，<strong>仅占有整个 EDen 空间的 1%</strong>，当然我们可以通过选项 ”-XX:TLABWasteTargetPercent“ 设置 TLAB 空间所占用 Eden 空间的百分比大小</li>
<li><strong>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配了内存</strong><ul>
<li><img src="https://api2.mubu.com/v3/document_image/35f2d985-eba5-4841-a508-f4bb9764f6e4-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为什么有 TLAB（Thread Local Allocation Buffer）</strong></p>
<ul>
<li>堆区是线程共享的，任何线程都可以访问到堆区中的共享数据。由于对象实例的创建在 JVM 中非常频繁，<strong>因此在并发环境下从堆区中划分内存空间是线程不安全的</strong></li>
<li><strong>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</strong></li>
<li><strong>所以有了 TLAB</strong></li>
</ul>
</li>
<li><p>逃逸分析   -XX:DoEscapeAnalysis 显式开启逃逸分析</p>
<ul>
<li>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，<strong>那就是如果经过逃逸分析（Escape Analysis)后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配 </strong>。<strong> 这样就无需在堆上分配内存，也无须进行垃圾回收了。</strong>这也是最常见的堆外存储技术。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用 </strong>，则认为<strong> 没有发生逃逸</strong>。</li>
<li>当一个对象在方法中被定义后，<strong>它被外部方法所引用，则认为发生逃逸。</strong>例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
<li>如何快速的判断是否发生了逃逸分析，就 <strong> 看 new 的对象实体是否有可能在方法外被调用</strong></li>
<li><strong>结论</strong><ul>
<li>开发中能使用局部变量的，就不要使用在方法外定义</li>
</ul>
</li>
</ul>
</li>
<li><p>代码优化</p>
<ul>
<li>使用逃逸分析，编译器可以对代码做如下优化：</li>
<li>栈上分配：将堆分配转化为栈分配。如果一个对象在子线程中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配<ul>
<li>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成之后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须机型垃圾回收了</li>
<li>常见的栈上分配场景：给成员变量赋值、方法返回值、实例引用传递</li>
</ul>
</li>
<li>同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步<ul>
<li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫 == 锁消除 ==</li>
</ul>
</li>
<li>分离对象或标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。<ul>
<li>如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来替代。这个过程就是标量替换</li>
</ul>
</li>
</ul>
</li>
<li><p>逃逸分析小结</p>
<ul>
<li>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做 <strong> 标量替换、栈上分配、和锁消除</strong>。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li>
<li>通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择</li>
</ul>
</li>
<li><p>栈、堆和方法区的交互</p>
<ul>
<li>reference 指向对象的实例数据，实例数据中有到对象类型数据的指针，这个指针指向方法区中的对象类型数据。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/7a448b77-9369-48e8-b83a-ae42c10dae10-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>JVM 没有使用句柄池的方式（增加了一次指针的开销）<ul>
<li><img src="https://api2.mubu.com/v3/document_image/2e95c125-00b0-4b68-8a4d-deab4e882a8e-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>方法区   <strong>在 jdk7 及以前，习惯上把方法区称为永久代。jdk8 开始，使用元空间取代了永久代</strong></p>
</li>
<li><p>方法区的演变</p>
<ul>
<li>jdk1.6 及之前：有永久代（permanent generation） ，静态变量存放在永久代上</li>
<li>jdk1.7：有永久代，但已经逐步“去永久代”，<strong>字符串常量池、静态变量移除，保存在堆中</strong></li>
<li>jdk1.8 及之后： 无永久代，<strong>类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</strong></li>
</ul>
</li>
<li><p>永久代为什么要被元空间替换</p>
</li>
<li><p>方法区的垃圾回收</p>
</li>
<li><p>StringTable （字符串常量池）为什么要调整到堆中</p>
<ul>
<li>jdk7 中将 StringTable 放到了堆空间中。因为永久代的回收效率很低，在 fullgc 的时候才会触发。而 full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存.</li>
</ul>
</li>
<li><p>内存布局</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3d17013b-524f-4c60-83f5-1988c9617bb0-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>对象在 JVM 是怎么存储的？对象头中有哪些东西？</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/04430d3c-ccab-4884-9a17-252635ebeded-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>对象头（Header）</p>
<ul>
<li>运行时元数据</li>
<li>类型指针：指向类元数据的 InstanceKlass，确定该对象所属的类型</li>
<li>说明：如果是数组，还需记录数组的长度</li>
</ul>
</li>
<li><p>编译型语言和解释型语言</p>
<ul>
<li><strong>编译型语言 </strong> 的执行方式是：先把这 10 行代码通过 <a href="https://baike.baidu.com/item/ 编译器 /8853067?fr=aladdin"> 编译器 </a> 全部编 <strong> 译成机器指令码的文件</strong>，然后再让计算机运行<ul>
<li><img src="https://api2.mubu.com/v3/document_image/a0b6d04d-ad8c-48ea-8f7e-3bf00e651de5-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><strong>解释型语言 </strong> 的执行方式就是：通过 <a href="https://baike.baidu.com/item/ 解释器 /10418965?fr=aladdin"> 解释器 </a> 一行一行的将代码翻译成机器指令码执行。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/541878de-4caf-4609-aea1-96c6996b5096-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>Java 代码来说，是将源文件（.java 文件）先 <strong> 编译 </strong> 成字节码文件（.class 文件），然后再在 <a href="https://baike.baidu.com/item/JVM/2902369?fr=aladdin">Java 虚拟机</a>（JVM）中<strong> 解释 </strong> 执行。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/51ede055-f9f8-4ab4-be18-cd70a2bb207c-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>JAVA 是半编译半解释的语言</p>
<ul>
<li><strong>Java 首先将源代码编译成字节码， 然后依赖各种不同平台上的虚拟机来解释执行字节码 </strong>，<strong> 从而实现了“一次编写，到处运行”的跨平台特性</strong>， 所以说 java 是半编译半解释型的语言。</li>
<li>编译器：将源代码编译成 class 字节码文件</li>
<li>解释器：将字节码文件中的内中翻译为 <strong> 对应平台 (windows 、linux)</strong> 的本地机器指令</li>
</ul>
</li>
<li><p>四种引用：软弱虚引用在一定条件下都是可以被回收的。<strong>相对而言，强引用是造成内存泄漏的主要原因之一。</strong></p>
<ul>
<li>强引用：只要强引用的对象是可触及的，被强引用的对象就不会被回收。比如这个”hello 双硅谷”<ul>
<li><img src="https://api2.mubu.com/v3/document_image/517f7338-19b9-404d-a4b9-890040b4829a-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/f222f539-c3d1-490d-8e79-27eb5819e443-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>如果 str 置为 null   这个时候就会被回收</li>
<li>软引用<ul>
<li><em>内存不足即回收   -Xms10m -Xmx10m  // 在报 OOM 之前，垃圾回收器会回收软引用的可达对象。</em><ul>
<li><img src="https://api2.mubu.com/v3/document_image/4049e061-4129-4167-b40e-cfdd9cfc32bf-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>弱引用<ul>
<li>// 不管当前内存空间足够与否，都会回收它的内存</li>
</ul>
</li>
<li>虚引用<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>GC 性能的几大指标</p>
</li>
<li><p>JVM 调优篇</p>
<ul>
<li>生产环境中的问题<ul>
<li>发生了内存移除怎么处理</li>
<li>给服务器分配多少内存合适</li>
<li>怎么对垃圾回收器调优</li>
<li>CPU 负载高怎么处理</li>
<li>分配多少线程比较合适</li>
<li>不加 log  怎么确定请求是否实行了某一行代码</li>
<li>不加 log  怎么实时查看某个方法的入参和返回值</li>
</ul>
</li>
<li>为什么要调优  防止 OOM  解决 OOM  减少 Full GC 出现的频率</li>
</ul>
</li>
<li><p>调优步骤</p>
<ul>
<li>性能监控、性能分析、性能调优<ul>
<li><img src="https://api2.mubu.com/v3/document_image/ce90f4e4-9aa1-4b6a-b962-030198e0d9cf-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>JVM 命令</p>
<ul>
<li>查看运行的 Java 进程<ul>
<li>jps Java Virtual Machine Process Status Tool</li>
<li>jps  显示 pid 和类名</li>
<li>jps -q  显示 pid</li>
<li>jps -l  显示 pid 和全限定名</li>
<li>jps -v  显示 JVM 参数</li>
</ul>
</li>
<li>查看 JVM 统计信息<ul>
<li>jstat Java Virtual Machine statistics monitoring tool<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b3a763dd-aae4-4e7f-b10c-10d33645edea-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>jstat -class pid<ul>
<li><img src="https://api2.mubu.com/v3/document_image/3899f590-e60a-4340-96ce-6f33017e02a3-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>每秒打印 1 次<ul>
<li><img src="https://api2.mubu.com/v3/document_image/915abbf5-56c2-4219-87fb-a0de77955ed1-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>类加载统计<ul>
<li><img src="https://api2.mubu.com/v3/document_image/2a642908-d15b-4927-873a-9206edbf7b51-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>垃圾回收统计   jstat -gc 2060<ul>
<li><img src="https://api2.mubu.com/v3/document_image/6f571dc1-8ef0-4e1e-85bc-9eddf338907f-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>堆内存统计  jstat -gccapacity 2060<ul>
<li><img src="https://api2.mubu.com/v3/document_image/fe0fd382-d937-4c95-be10-c1838c1a03fe-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>新生代垃圾回收统计<ul>
<li><img src="https://api2.mubu.com/v3/document_image/400b51e0-c385-4b21-9011-e4781f2d155f-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>总结垃圾回收统计<ul>
<li><img src="https://api2.mubu.com/v3/document_image/8efc6046-dd8d-4141-bc94-441e3d8c7879-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li>查看 JVM 参数   jinfo<ul>
<li><img src="https://api2.mubu.com/v3/document_image/bc7e9da1-3957-4ff8-9563-d28761ee7666-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>导出内存映像文件   获取 dump 文件 作用  出现了堆溢出时可以用 dump 文件分析<ul>
<li><img src="https://api2.mubu.com/v3/document_image/1f928e57-bb28-4b3f-bcc0-b96295137a84-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><ul>
<li><img src="https://api2.mubu.com/v3/document_image/1912078b-7ce1-4c95-9861-ba7f9d208833-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>打印线程快照  jstack pid</p>
</li>
<li><p>排查</p>
</li>
<li><p>jstack 实战之高 cpu 占用率排查</p>
<ul>
<li><strong>1、</strong>使用 top 指令，定位 CPU 占用较高的进程。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0251434d-d9dd-4bd5-bafe-4266e9506909-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>2. 使用 top -H -p ${进程 id}指令，查看指定进程下各个线程的 cpu 使用情况<ul>
<li><img src="https://api2.mubu.com/v3/document_image/e739a85b-0208-41a3-bedc-35bc736402b3-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>注意：PID 虽然名为进程控制符，<strong>但其用途不限于特指进程 id</strong>。如上图中 PID 列指的就是线程的 id</li>
<li>3. 使用 printf “%x” xxx 指令，将 1977 转换为 16 进制<ul>
<li><img src="https://api2.mubu.com/v3/document_image/4609dd90-6770-4fa7-bcd0-b93de9159260-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><strong>4</strong>使用 jstack pid 指令，查看当前的堆栈信息；并 <strong> 根据上一步得到的 16 进制的线程 id，找到肇事线程</strong>。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/b705c322-4bcb-4d2f-a20c-679e9bb3d3b4-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>如果线程较多的话，我们可以使用 grep 指定来根据关键字定位行，jstack 1956 | grep -10 7b9 显示 10 行</li>
<li><strong>5：</strong>分析肇事线程堆栈信息。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/d510fb6a-e43b-490d-a9cc-22228356acbf-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>我们已经定位到位置 6，然后去找代码即可<ul>
<li><img src="https://api2.mubu.com/v3/document_image/2827bed2-0a3d-466e-908b-c2aa6ecef481-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>jstack 之死锁排查</p>
<ul>
<li><strong>1、</strong>使用 jps 指令，查看所有 java 进程。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0659ef78-4f38-493f-8da8-604708b74515-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><strong>2、</strong>使用 jstack pid 指令，查看指定进程的堆栈信息, 观察并定位到死锁线程。<ul>
<li><img src="https://api2.mubu.com/v3/document_image/bb313bdc-ae62-47f5-b37b-02259adfb9ee-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>jcmd  包括了之前 的所有  jcmd -l 列出所有进程 pid 号</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/5be5237a-7cd7-4a39-abb4-96b01ade100b-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/cbc0cd05-760c-4128-886c-093b94fec7f8-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>内存泄漏和内存溢出</p>
<ul>
<li>内存泄露：对象不会再被程序引用了，但是 GC 又不会回收他们</li>
<li>内存溢出：内存不够分配新对象了</li>
<li>两者关系：内存泄漏的增多最终会导致内存溢出。</li>
</ul>
</li>
<li><p>JAVA 中内存泄漏的情况</p>
<ul>
<li><p><img src="https://api2.mubu.com/v3/document_image/89af9633-3827-4eb5-b611-2a4675fe023b-12259280.jpg" alt="img"></p>
</li>
<li><p>静态集合类</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/0fdd6986-18a2-46bd-8a72-ddd1320c82e6-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>单例模式<ul>
<li><img src="https://api2.mubu.com/v3/document_image/4f05caf6-0f14-40ab-9107-20bcd27e1dc3-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>内部类持有外部类<ul>
<li><img src="https://api2.mubu.com/v3/document_image/a2e9b2b7-8c36-466f-8c3b-267e3a89b70f-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>不释放连接<ul>
<li><img src="https://api2.mubu.com/v3/document_image/a52b8862-bac3-4812-b850-79608684003b-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>改变哈希值  当我们想把自定义对象存入 map 时就要保证对象的 hashcode 不变<ul>
<li><img src="https://api2.mubu.com/v3/document_image/f1c15ebe-5199-4313-a900-4bd84caa2524-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>缓存问题<ul>
<li><img src="https://api2.mubu.com/v3/document_image/5e4b4094-7e36-432e-b3c3-944a76e0ee37-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>内存泄漏案例</p>
<ul>
<li>第一个只是移动了指针，实际上栈顶的数据还在，没有被回收<ul>
<li><img src="https://api2.mubu.com/v3/document_image/8ae1dd10-9486-4e31-a4a6-492cf016fef2-12259280.jpg" alt="img"></li>
</ul>
</li>
<li>解决   将栈顶元素置空</li>
</ul>
</li>
<li><p>Eden 区和两个 S 区理论上是 8:1:1，但实际上是 150:25:25，也就是 6:1:1，原因是有一个参数 UseAdaptiveSizePolicy，默认开启，它会自动选择各区大小的比例。虽然查出来 SurvivoRatio=8, 但没有启用，当 UseAdaptiveSizePolicy 禁用时 且显式地写出 SurvivoRatio=8 才会出现 8:1:1 的比例</p>
<ul>
<li><img src="https://api2.mubu.com/v3/document_image/33ae6bd9-0aa6-4530-a9d1-4bf42dd7b74f-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/cdc67e2a-9551-47ea-b304-d38657a79644-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/3c415e11-318c-4806-b4a6-cbfed2572dd0-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/ca3725c0-fb71-4d52-bbf1-c54a5cfe2e82-12259280.jpg" alt="img"></li>
<li><img src="https://api2.mubu.com/v3/document_image/7df214b3-2fea-4370-837b-33beb3d76b87-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><p>1.4 动态对象年龄判定</p>
</li>
<li><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当 <strong> 累积的某个年龄大小超过了 survivor 区的一半时 </strong>，<strong> 取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</strong></p>
</li>
<li><p>需要注意的是：<strong>对象默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p>
</li>
<li><ul>
<li><img src="https://api2.mubu.com/v3/document_image/dd8f0efc-a6ba-457d-b84f-c47b389e673f-12259280.jpg" alt="img"></li>
</ul>
</li>
<li><ul>
<li><img src="https://api2.mubu.com/v3/document_image/ca4e0e3b-6e72-4cd6-8a1b-cfa2ceb7e4ca-12259280.jpg" alt="img"></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《Redis 设计与实现》读书笔记</title>
    <url>/2021/10/26/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="Redis 中的数据结构"><a href="#Redis 中的数据结构" class="headerlink" title="Redis 中的数据结构"></a>Redis 中的数据结构 </h5><h6 id="字符串"><a href="# 字符串" class="headerlink" title="字符串"></a> 字符串</h6><p>&emsp;&emsp; 简单动态字符串的结构：使用一个结构体来表示，其内部有一个<strong>buf 数组(保存字符串)，以及字符串长度 len，剩余长度 free 等字段</strong>，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。</p>
<span id="more"></span>
<p><img src="https://api2.mubu.com/v3/document_image/aef323e1-d81e-45b5-bc34-78f82fca759f-12259280.jpg" alt="img"></p>
<p>&emsp; 简单动态字符串 (SDS) 与 C 语言字符串的区别</p>
<ul>
<li><p>1. 常数复杂度获取字符串长度</p>
<ul>
<li>len 表示已经使用字节的数量 (也就是字符串的长度，这样就可以 O(1) 复杂度获取字符串的长度)</li>
<li>即使对一个非常长的字符串键执行 strlen 命令，也不会对系统性能造成影响，因为 strlen 复杂度仅为 O(1)</li>
</ul>
</li>
<li><p>2. 杜绝缓冲区溢出</p>
<p><img src="https://api2.mubu.com/v3/document_image/d531493d-261f-42e3-a5d0-a1249a3655d9-12259280.jpg" alt="img"></p>
<ul>
<li>C 字符串不记录自身长度带来的一个问题是容易造成缓冲区溢出：执行 strcat 时如果忘记分配足够空间，s1 的数据就会溢出到 s2 所在的空间中  如图，执行 strcat 之前没有分配足够空间，s1 就变成了 rediscluster，也就是 s1 的内容溢出到了 s2 所在位置<img src="https://api2.mubu.com/v3/document_image/81fcb70e-7b3e-4d79-b919-4262e4695044-12259280.jpg" alt="img"></li>
<li>SDS 空间分配策略：需要对 SDS 进行修改时，<strong>先会检查 SDS 的空间是否满足修改所需的要求，不满足要求的话就先拓展 SDS 的空间</strong>，再执行 sdscat 拼接操作</li>
</ul>
</li>
<li><p>3. 减少修改字符串时带来的内存重分配次数</p>
<ul>
<li><p>对于一个包含了 N 个字符的 C 字符串来说，底层实现总是一个 N+1 个字符长的数组(‘\0’作为结束标志)，所以每次增长或者缩短 C 字符串，都要对保存这个 C 字符串的数组进行内存重分配操作。</p>
<ul>
<li><p>如果是拼接操作 append，执行这个操作之前，程序先要内存重分配来扩展底层数组的大小——如果忘了这一步就会产生 <strong> 缓冲区溢出</strong></p>
</li>
<li><p>如果是裁剪操作 trim，执行这个操作之后，程序需要内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生 <strong> 内存泄露</strong></p>
</li>
</ul>
</li>
<li><p>在一般程序中，如果修改字符串长度的情况不经常出现，那么每次修改都执行一次内存重分配是可以接受的，但是<strong>redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话</strong>，内存重分配的时间就会占据修改字符串所用时间段一大部分，如果频繁修改还可能对性能造成影响。</p>
</li>
</ul>
</li>
<li><p>4. 减少内存分配次数采取的策略：<strong>空间预分配 </strong> 以及 <strong> 惰性空间释放</strong></p>
<ul>
<li>空间预分配：<ul>
<li>修改后的 SDS&lt;1MB，程序分配和 len 属性同样大小的未使用空间，此时 SDS 的 len 与 free 大小相等。比如修改后实际存储字符串的空间变为 13 字节，那么 len=13，free=13，buf 数组整体的长度 =13+13+1=27（额外 1 字节保存结束符）</li>
<li>修改后 SDS&gt;=1MB。程序会分配 1MB 的未使用空间。比如修改后实际存储字符串的空间变为 2MB，那么 len=2M，free=1MB，buf 数组整体的长度 =2MB+1MB+1byte</li>
</ul>
</li>
<li>惰性空间释放：用于优化 SDS 字符串 <strong> 缩短操作 </strong>。当 SDS API 需要缩短保存的字符串时，程序并<strong> 不立即回收这部分内存，而是使用 free 属性将字节的数量记录，等待使用。</strong>与此同时，SDS 提供了相关 API，<strong>在有需要时，真正释放未使用空间</strong></li>
</ul>
</li>
</ul>
<h6 id="字符串总结"><a href="# 字符串总结" class="headerlink" title="字符串总结"></a>字符串总结 <img src="https://api2.mubu.com/v3/document_image/a41abab9-9440-4535-b78d-7475be0c171b-12259280.jpg" alt="img"></h6><h6 id="链表"><a href="# 链表" class="headerlink" title="链表"></a> 链表 </h6><p> 双向链表结构，使用 adlist.h/list 来持有，操作链表<img src="https://api2.mubu.com/v3/document_image/f104c56b-d380-44cd-a64a-28fb51eeba76-12259280.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/81d2b496-b86c-4d50-8900-c95034f36dc1-12259280.jpg" alt="img"></p>
<p>链表总结</p>
<ul>
<li>双端：链表节点带有 prev 和 next 指针，获取前置和后置节点的复杂度都是 O(1)</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。 带表头指针和表尾指针，带链表长度计数器 </li>
<li>头尾指针：将程序获取头尾节点的复杂度降为 O(1)</li>
<li>长度计数器：将程序获取表长的复杂度降为 O(1)</li>
<li>多态：链表节点使用 void* 指针来保存节点值，并且可以通过 list 结构的 dup、free、match 为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li>
</ul>
<h6 id="字典"><a href="# 字典" class="headerlink" title="字典"></a>字典</h6><p>&emsp; 数组中的每个元素都是指向 dict.h/dictht 的结构，dictEntry 就是一个键值对<img src="https://api2.mubu.com/v3/document_image/2ce1d861-37a6-4e50-bd6a-f31a52b72403-12259280.jpg" alt="img"></p>
<p>Redis 中的字典由 dict.h/dict 实现，由这个数据结构将字典组织在一起</p>
<p><img src="https://api2.mubu.com/v3/document_image/d5280468-3589-4c38-8a7a-c457c4c0c608-12259280.jpg" alt="img"></p>
<ul>
<li>ht 属性是包含两个项的数组，<strong>每项都是一个哈希表 </strong>，<strong>ht[0] 平时使用，而 ht[1]仅在 rehash 时使用</strong>。</li>
<li>rehashidx 记录了 rehash 的进度，初始为 -1</li>
<li>解决键冲突：链地址法，为了提高速度，每次都是 <strong> 将新节点添加到链表的表头位置</strong>，复杂度为 O(1)（这点跟 hashmap 不一样）</li>
</ul>
<p>rehash 的过程</p>
<ul>
<li>1. 为字典 ht[1]哈希表分配空间，大小取决于要执行的操作与 ht[0]当前键值对的数量，将保存在 ht[0]中的所有键值对存放到 ht[1]指定的位置</li>
<li>2. 当 ht[0]的所有键值对都迁移完毕后，释放 ht[0]，并指向 ht[1]，并在 ht[1]上创建一个空的哈希表，为下次 rehash 准备。</li>
</ul>
<p>扩容的条件</p>
<ul>
<li>服务器目前 <strong> 没有在执行 </strong>BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的<strong> 负载因子 &gt;=1</strong></li>
<li>服务器 <strong> 正在执行 </strong>BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的<strong> 负载因子 &gt;=5</strong></li>
</ul>
<p>为什么根据 BGSAVE 命令或 BGREWRITEAOF 命令来判断是否扩展？</p>
<ul>
<li>执行这些命令时，Redis 需要创建当前服务器进程的子进程，大多数操作系统采用 <strong> 写时复制技术 </strong> 来优化子进程使用效率，此时提高负载因子，可以尽量避免子进程对哈希表扩展，避免不必要的内存写入操作，节约内存。</li>
<li>Redis 在持久化时，如果是采用 BGSAVE 命令或者 BGREWRITEAOF 的方式，那 Redis 会 <strong>fork 出一个子进程来读取数据，从而写到磁盘中</strong>。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断 page-fault)，这样就得耗费不少性能在复制上。<strong> 而在 rehash 阶段上，写操作是无法避免的。</strong>所以 Redis 在 fork 出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。</li>
</ul>
<p>渐进式 hash</p>
<ul>
<li>rehash 时会将 ht[0]中所有的键值对 rehash 到 ht[1]，如果 <strong> 键值对很多并且一次性操作的话，容易导致服务器在一段时间内停止服务 </strong>。为避免这种情况，Redis 采用渐进式 rehash，将 ht[0] 中的键值对 <strong> 分多次，慢慢的 rehash 到 ht[1]之中</strong>。</li>
</ul>
<p>渐进式 hash 的步骤</p>
<ul>
<li>1. 为 ht[1]分配空间，让字典同时持有两个哈希表。</li>
<li>2. 在字典中维持一个索引计数器变量 rehashidx，将其设置为 0，表示 rehash 正式开始。</li>
<li>3. 在 rehash 进行期间，每次对字典进行添加，删除，查找或更新操作时，程序除了执行指定的操作外，还会将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成后，将 rehashidx++。</li>
<li>4. 某个时刻，ht[0]中的所有键值对都被 rehash 至 ht[1]，此时设置 rehashidx= -1 时，表示 rehash 操作已经完成。</li>
</ul>
<p>渐进式 hash 的好处</p>
<p>&emsp; 采用了分而治之的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个操作中，从而避免集中式 rehash 带来庞大计算量</p>
<p>&emsp; 在 rehash 的期间，字典同时使用 ht[0]，ht[1]两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在 ht[0]里面查找，如果为空，就继续到 ht[1]里查找 </strong>。在此期间，<strong> 新增的键值对都会被添加到 ht[1]中 </strong>，ht[0] 不承担任何添加操作，<strong>保证 ht[0]中的键值对只能是越来越少</strong>。</p>
<h6 id="跳表"><a href="# 跳表" class="headerlink" title="跳表"></a>跳表 </h6><p>　跳跃表是一种<strong> 有序的 </strong> 数据结构，通过在每个节点 <strong> 维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。Redis 只有在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中作为内部数据结构。</p>
<p><img src="https://api2.mubu.com/v3/document_image/cf9cb1d2-8ec5-4026-b32c-e8c7f22db422-12259280.jpg" alt="img"></p>
<p><img src="https://api2.mubu.com/v3/document_image/ea8f1d97-b799-4ee3-ace2-d64bc5598109-12259280.jpg" alt="img"></p>
<p>　1. 层—level</p>
<p>　　跳跃表的每个节点都会包含多个层，每次创建一个新跳跃表时，都会根据 <strong> 幂次定律</strong>，随机生成一个<strong>1~32 之间的数作为层的大小</strong>。每个层都会包含前进指针和跨度</p>
<p>　2. 前进指针（forword）</p>
<p>　　用于访问下一个节点。跨度表示两个节点之间的距离，指向 NULL 的所有前进指针的跨度为 0。跨度用于计算排位，访问某一结点的 <strong> 经过的跨度之和就是当前节点的排位</strong></p>
<p>　3. 后退指针—backward</p>
<p>　　用于从表尾向表头方向访问节点，<strong>前进指针可以一次跳过多个节点 </strong>，<strong> 后退指针只能后退至前一个节点</strong>，因为每个节点只有一个后退指针。</p>
<p>　4. 分值—score</p>
<p>　　分值是一个 double 类型的浮点数，跳跃表中节点都按照分值排序。</p>
<p>　5. 成员对象—obj</p>
<p>　　是一个指针，指向字符串 SDS 对象。一个跳跃表中，对象必须是唯一的，但分值可以相同。相同时按对象字典序来排序。</p>
<p>　Redis 的 level 个数 <strong> 为什么要用幂次定律生成</strong>（随机生成节点的层数）？</p>
<p>　　通过幂次定律能保证 <strong> 越高 level 的结点数量越少 。保证索引等级越高，参与索引建立的元素越少，如果每层都有很多 level，那么这个索引建立的就没有意义了。</strong></p>
<p>　为什么不用最均衡的方式，按照节点分数的排序情况均匀建立索引？</p>
<p>　　考虑到下一个插入的元素具有随机性，这样设计不容易出现最坏的情况。如果每次都以均匀固定的方式建索引，维护的成本很高，跳跃表的优点就是维持结构平衡的成本低，完全依靠随机。跳跃表相比二叉树有一个优势就在于不需要主动 rebalance 去维护平衡。</p>
<p>　跳表的查找过程</p>
<p>　　此时跳跃表查找 10，会先从 header 节点（O1）的最高层（L3）寻找，发现要查找的数小于 23.２则返回，继续从下一个有后继的层开始寻找，当发现要查找的数小于 11.0 时，则从 O1 的下一层找，此时到 O2 的 L1，发现要查找的数大于 7.0，则从 L1 找，直到查找到相邻节点为止。<img src="https://api2.mubu.com/v3/document_image/4dbbfdf9-4dfe-41f1-a0b2-f3fc8c0a1ddd-12259280.jpg" alt="img"></p>
<p>　为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>　　如果 <strong> 只使用字典存储，由于是无序的，所以每次在范围查询时，需要排序 </strong>，时间复杂度 O(nlogn) 为和额外 O(n)  的内存空间，因为要创建一个数组存储排序后的元素。 如果 <strong> 只用跳跃表实现，根据成员查找分值时，复杂度将为 O(logn)</strong> 。综上，为了让有序集合的分值查找和范围查找都尽可能快地执行，Redis 选择字典和跳跃表两种数据结构结合的方式</p>
<p>　跳表时间复杂度<img src="https://api2.mubu.com/v3/document_image/5b934ef8-c434-473d-88d0-faa17f1821e1-12259280.jpg" alt="img"></p>
<h5 id="数据库"><a href="# 数据库" class="headerlink" title="数据库"></a>数据库</h5><p>　Redis 把所有库信息都保存在 redis.h/redisServer 结构的 db 数组中，数组类型是 redis.h/redisDB，dbnum 决定着应该创建多少数据库中的 db，默认为 16，clients 维护着所有连接 Redis 的客户端<img src="https://api2.mubu.com/v3/document_image/79cb9883-2f79-4a5b-8a0f-60e0eebc74ab-12259280.jpg" alt="img"></p>
<p>切换库时，其实就是 redisClient.db 对 redisServer.db 数组的目标数据库指针的移动　<img src="https://api2.mubu.com/v3/document_image/81d85ea8-e660-4a79-b3fa-b4ffb356ee94-12259280.jpg" alt="img"></p>
<h6 id="存储过期时间"><a href="# 存储过期时间" class="headerlink" title="存储过期时间"></a>存储过期时间</h6><p>　redisDb 中有一个 expires 的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个 long long 类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的 Unix 时间戳）</p>
<p><img src="https://api2.mubu.com/v3/document_image/0089123b-1ace-428f-8d52-dd5d37c830be-12259280.jpg" alt="img"></p>
<h6 id="过期键删除策略"><a href="# 过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h6><p>　定时删除：设置键的过期时间时，创建定时器，过期时，定时器立刻执行键的删除。</p>
<p>　惰性删除：不着急删除过期键，每次获取时都会进行过期校验</p>
<p>　定期删除：隔一段时间，程序就对数据库检查，删除过期键</p>
<h6 id="删除策略的特点"><a href="# 删除策略的特点" class="headerlink" title="删除策略的特点"></a>删除策略的特点 </h6><p>　定时删除：<strong> 对内存友好，但对 CPU 不友好。</strong>过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。<strong>Redis 定时器需要创建时间事件</strong>，时间事件底层由无序链表实现，查找复杂度为 O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p>
<p>　惰性删除：<strong>对 CPU 友好，但对内存不友好 </strong>。不需要把时间浪费在非相关键的删除上。如果有非常多的过期键，这些键又恰好没有被访问到的话，那么它们永远不会被删除，除非用户手动执行 flushdb，我们甚至可以把<strong> 这种情况下看作是一种内存泄露 </strong>。当键非常多时，会导致内存泄漏，因为<strong> 只有用到时才会判断，删除</strong>。</p>
<p>　定期删除：<strong>定时删除占用太多 CPU 时间，影响响应时间，惰性删除浪费太多内存，有内存泄露的风险 </strong>。<font color="red"> 定期删除是一种折衷的方式</font>，隔一段时间执行一次，并限制删除操作执行的时长和频率减少对 CPU 的占用；定期删除还能减少庞大的过期键对内存的占用。</p>
<p>　<strong>难点是如何确定时长和频率，执行得太频繁或者执行时间太长，会退化为定时删除，执行得太少或者执行时间太短，会退化为惰性删除</strong>，因此，服务器必须根据情况，合理设置删除的执行时长和执行频率。</p>
<h5 id="redis 持久化"><a href="#redis 持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h5><p>　RDB 持久化：RDB 文件是经过压缩的二进制文件，可通过该文件还原成数据库状态</p>
<p>　AOF 持久化：采用日志的形式来记录每个写操作，并追加到文件中</p>
<h6 id="RDB 与 AOF 共存的载入情况"><a href="#RDB 与 AOF 共存的载入情况" class="headerlink" title="RDB 与 AOF 共存的载入情况"></a><strong>RDB 与 AOF 共存的载入情况 </strong></h6><p>　由于 AOF 文件的更新频率更高，因此开启 AOF 持久化功能后，启动时<strong> 优先加载 AOF 还原数据</strong>，只有在 AOF 处于关闭状态，才使用 RDB 文件恢复数据</p>
<h6 id="SAVE 和 BGSAVE 的区别"><a href="#SAVE 和 BGSAVE 的区别" class="headerlink" title="SAVE 和 BGSAVE 的区别"></a>SAVE 和 BGSAVE 的区别 </h6><p>　SAVE 会<strong> 阻塞 Redis 服务器进程 </strong>，直到 RDB 文件创建完毕为止，<strong> 阻塞期间，服务器不能处理任何命令请求。</strong></p>
<p>　<strong>BGSAVE 会 fork 出一个子进程 </strong>，由<strong> 子进程负责创建 RDB 文件，父进程继续处理命令请求</strong>。当子进程完成之后，向父进程发送信号</p>
<h6 id="服务器是如何根据 save 选项来自动执行 BGSAVE 的？"><a href="# 服务器是如何根据 save 选项来自动执行 BGSAVE 的？" class="headerlink" title="服务器是如何根据 save 选项来自动执行 BGSAVE 的？"></a>服务器是如何根据 save 选项来自动执行 BGSAVE 的？</h6><p>　主要是根据<strong>dirty 计数器和 lastsave 属性，</strong>dirty 计数器记录距离上次成功执行 SAVE 或 BGSAVE 后数据库被修改了几次，lastsave 是一个 UNIX 时间戳，记录上次成功执行 SAVE 或 BGSAVE 的时间</p>
<h6 id="AOF 文件的载入与数据还原"><a href="#AOF 文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h6><ul>
<li>1. 创建一个没有网络连接的伪客户端。因为 Redis 命令只能在客户端上下文中执行，并且 AOF 文件在本地而不是网络</li>
<li>2. 解析 AOF 文件并取出一条写命令</li>
<li>3. 使用 <strong> 伪客户端 </strong> 执行被读出的写命令</li>
<li>4. 持续执行 2 和 3，直到所有写命令都已经执行完毕<img src="https://api2.mubu.com/v3/document_image/135f9792-2877-463e-9054-7cb6d49022f1-12259280.jpg" alt="img"></li>
</ul>
<h6 id="AOF 重写"><a href="#AOF 重写" class="headerlink" title="AOF 重写"></a>AOF 重写 </h6><p>　<strong> 因为 AOF 持久化会将所有的写命令都记录，所以会有冗余情况 </strong>，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong> 瘦身机制确保 AOF 里存的都是必不可少的精华</strong></p>
<p>　Redis 提供 AOF 文件重写功能，让服务器创建一个新的 AOF 文件，替代现有的 AOF 文件，减少冗余命令。<strong>虽然名字叫 AOF 重写，但是在新的 AOF 文件的重写过程中，不会读取旧 AOF 文件，而是通过读取数据库状态来实现的 </strong>。首先<strong> 从数据库中读取键现在的值，然后用一条命令记录键值对</strong>，代替之前记录的多条命令。</p>
<p>　比如 RPUSH  list “A”  RPUSH list  “B” RPUSH  list “C” RPUSH  list “D” RPUSH list  “E” ，如果没有 AOF 重写，AOF 文件要保存 5 条命令，<strong>如果服务器想要用尽量少的命令来记录 list 的状态，最简单高效的办法不是去读取和分析 AOF 文件的内容，而是直接从数据库中读取 list 键的值</strong>，然后用一条 RPUSH list “A” “B” “C” “D” “E”代替 5 条命令</p>
<h6 id="AOF 重写过程"><a href="#AOF 重写过程" class="headerlink" title="AOF 重写过程"></a>AOF 重写过程 </h6><p>　AOF 重写的过程中会有<strong> 大量的写入操作 </strong>，为了<strong> 避免 Redis 服务器长时间的阻塞 </strong>，重写工作将被<strong> 放到子进程中进行 </strong>。这样<strong> 父进程仍然可继续处理请求</strong></p>
<p>　子进程在执行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致当前数据库状态与重写后的 AOF 文件保存状态不一致。为解决这个问题，<strong>设置了 AOF 重写缓冲区</strong></p>
<p>　当重写子进程创建后，Redis 服务器执行完写命令就会将其写入 AOF 缓冲区和 AOF 重写缓冲区，子进程执行重写期间，服务器进程要执行 3 个工作：</p>
<ul>
<li><p>执行客户端发来的命令。</p>
</li>
<li><p>将执行后的写命令追加到 AOF 缓冲区</p>
</li>
<li><p>将执行后的写命令追加到 AOF 重写缓冲区<img src="https://api2.mubu.com/v3/document_image/f7d5cbc6-ea87-4ae1-8a78-f74561e57503-12259280.jpg" alt="img"></p>
</li>
</ul>
<p>　当子进程完成重写后，<strong>会向父进程发送一个信号 </strong>，父进程接收并调用信号处理函数，将<strong> 重写缓冲区的所有内容写到新 AOF 文件中，原地覆盖现有的 AOF 文件 </strong>。因此整个 AOF 文件重写的过程中，<strong> 只有信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p>
<h5 id="主从复制"><a href="# 主从复制" class="headerlink" title="主从复制"></a>主从复制 </h5><p>　通过 SLAVEOF 命令或配置文件中设置 slaveof 选项设置主从，Redis 的复制功能分为<strong> 同步 </strong> 和<strong>命令传播 </strong> 俩操作：</p>
<ul>
<li>同步用于把 slave 的数据库状态更新至 master 的数据库状态</li>
<li>命令传播是在 master 的数据库状态被修改时，导致主从数据库状态不一致，让主从回到一致的过程</li>
</ul>
<h6 id="同步和命令传播过程"><a href="# 同步和命令传播过程" class="headerlink" title="同步和命令传播过程"></a>　同步和命令传播过程 </h6><h6 id="同步"><a href="# 同步" class="headerlink" title="同步"></a> 同步</h6><ul>
<li>slave 向主发送 SYNC 命令。</li>
<li>master 接收并执行 BGSAVE，后台生成 RDB 文件，并用 <strong> 一个缓冲区记录现在开始执行的所有写命令</strong>。</li>
<li>BGSAVE 执行完毕时，master 将 RDB 文件发给 slave，slave 接收并载入，更新数据库状态。</li>
<li>master<strong>将其记录在缓冲区的所有写命令发给 slave</strong>，slave 执行写命令<img src="https://api2.mubu.com/v3/document_image/0502a38d-b4a5-42a7-bde5-666c372ded94-12259280.jpg" alt="img"></li>
</ul>
<h6 id="命令传播"><a href="# 命令传播" class="headerlink" title="命令传播"></a>　命令传播</h6><p>　　当 master 发生写操作时，主从同步需要通过命令传播，master 将写命令发送给 slave，slave 接收并执行相同的写命令</p>
<h5 id="一次完整的主从复制过程"><a href="# 一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程 </h5><p>　一次完整的复制过程可以分为<strong> 设置主服务器的地址和端口、建立套接字连接、发送 PING 命令、身份验证、发送端口信息、同步、命令传播</strong></p>
<ul>
<li>1. 设置主服务器的地址和端口：当客户端向 slave 发送 slaveof 127.0.0.1:6379 时，slave 要将客户端给定的 ip 和端口号都保存后发送 OK。这是一个异步命令，所以复制工作在回复 OK 后再执行。</li>
<li>2. 创建连向 master 的套接字连接，如果成功，slave 会给它关联一个处理复制工作的文件事件处理器（负责接收 RDB，传播的命令等）。主从成功连接后，master 会创建从服务器的客户端状态，<strong>将 slave 看做是一个客户端来看待</strong><img src="https://api2.mubu.com/v3/document_image/00a7b512-8ce2-4aab-a504-12e4d5887aa6-12259280.jpg" alt="img"></li>
<li>发送 PING 命令：slave 在套接字连接后做的第一个工作就是发送 PING 命令，<strong>检查套接字读写状态是否正常</strong>；主服务器能否正常处理命令请求。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</li>
<li>身份验证：收到 <strong>master 的 pong 回复</strong> 之后，检查从服务器是否设置<strong>masterauth，如果设置则进行身份验证</strong></li>
<li>发送端口信息：slave<strong>向 master 发送自己监听的端口号</strong>，master 保存这个端口号，也就是 12345</li>
<li>同步：从服务器发送 PSYNC 命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</li>
<li>命令传播：完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行</li>
</ul>
<h6 id="心跳机制"><a href="# 心跳机制" class="headerlink" title="心跳机制"></a>心跳机制 </h6><p>　在命令传播阶段，从服务器默认 1 秒一次发送 REPLCONF ACK <replication_offset> 命令给主服务器，<strong>replication_offset 是复制偏移量</strong>。这么做有 3 个作用：</replication_offset></p>
<ul>
<li>检测主从网络状态：若主服务器超过一秒没收到从服务器的 REPLCONF ACK 则表示连接有问题。</li>
<li>辅助实现 min-slave 选项：min-slaves-to-write 3 min-slaves-max-lag 10 表示从服务器数量少于 3 或 3 个从服务器延迟大于等于 10s 时，主服务器拒绝写命令。</li>
<li>检测命令丢失：如果 master 传播给 slave 的写命令在半路丢失，那么 slave 向 master 发送 REPLCONF ACK 时，master 发现 slave 当前的复制偏移量少于自己的复制偏移量，就从积压缓冲区里找到并补发。<img src="https://api2.mubu.com/v3/document_image/799f8eb4-35cb-453c-b135-d8cb51f5a0a3-12259280.jpg" alt="img"></li>
</ul>
<p>如图所示，这时会将复制缓冲区里面复制偏移量为 201-233 的命令重发</p>
<h5 id="Sentinel 机制"><a href="#Sentinel 机制" class="headerlink" title="Sentinel 机制"></a><strong>Sentinel 机制 </strong></h5><p>　Sentinel（哨兵）是 Redis 的<strong> 高可用性 </strong> 的解决方案，由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器升级为新的主服务器。从而实现故障转移，<strong>当原来的主服务器重新上线时，会被降级为从服务器。</strong></p>
<h6 id="Sentinel 系统对主服务器执行故障转移的过程"><a href="#Sentinel 系统对主服务器执行故障转移的过程" class="headerlink" title="Sentinel 系统对主服务器执行故障转移的过程"></a>　Sentinel 系统对主服务器执行故障转移的过程</h6><ul>
<li>检测 <strong> 主观下线 </strong> 状态：Sentinel 默认每秒与创建命令连接的实例 <strong> 发送 PING 命令 </strong>，通过回复判断是否在线。由于每个 Sentinel 中的<strong> 主观下线时间配置都可以不同，所有有可能某个 Sentinel 判断主观下线时，另一个 Sentinel 认为在线状态</strong></li>
<li>检查 <strong> 客观下线 </strong> 状态：当 Sentinel 判断主服务器为主观下线时，还会向其他 Sentinel 询问，得到足量数据已下线判断后，就会判定服务器为客观下线，并执行故障转移。</li>
<li><strong>选举领头 Sentinel</strong><ul>
<li>当主服务器被判断为客观下线时，sentinel 会协商选举领头 sentinel，并由领头 sentinel 对下线主服务器执行故障转移操作</li>
<li>当 SENTINEL is-master-down-by-addr 命令 <strong> 已经确认主服务器客观下线时 </strong>，Sentinel 还会再发送带有选举性质的命令，<strong> 并且带上自己的运行 ID</strong>。如果接收命令的 Sentinel 还没设置局部领头时，就会将这个运行 ID 作为自己的 Multi Bulk 回复参数。根据回复参数来判断多少 sentinel 将自己设置为局部领头。可能根据网络延迟，有的 Sentinel 命令比其他 Sentinel 都先到达，并且胜出（必须有半数以上的票），那么就由它负责故障转移。一次选举没有产生，一段时间后再次选举，直到选出</li>
</ul>
</li>
</ul>
<h5 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h5><p>　出现的原因：主从复制不能实现高可用、业务需要更高的 QPS，而主从复制中单机的 QPS 可能无法满足业务需求</p>
<p>​    节点取余方式：对每个数据进行 hash 运算之后，与节点数进行取余运算，根据余数不同保存在不同的节点上，<strong>优点是配置简单，缺点是数据节点伸缩时，导致数据迁移</strong></p>
<p>　一致性哈希方式：将所有的数据当做一个哈希环，哈希环中的数据范围是 0-2＾32。然后为每一个数据节点分配一个哈希值，<strong>这个节点就负责保存这个范围内的数据 </strong>。对<strong> 每一个 key 进行 hash 运算，被哈希后的结果在哪个 node 的范围内，则 <font color="red"> 按顺时针去找最近的节点 </font>&gt;，这个 key 将会被保存在这个节点上。</strong> 优点是 <font color="red"> 节点伸缩时，只影响邻近节点</font></p>
<p><img src="https://api2.mubu.com/v3/document_image/42cee358-df0c-4e1d-b0f1-655e92f976d1-12259280.jpg" alt="img">**</p>
<h6 id="分配槽"><a href="# 分配槽" class="headerlink" title="分配槽"></a>分配槽 </h6><p>　1. 每个节点通过通信都会共享 Redis Cluster 中<strong> 槽和集群中对应节点的关系</strong></p>
<p>　2. 客户端向 Redis Cluster 的任意节点发送命令，接收命令的节点会根据 CRC16 规则进行<strong>hash 运算与 16383 取余</strong>，计算自己的槽和对应节点 </p>
<p>　3. 如果保存数据的槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端 </p>
<p>　4. 如果保存数据的槽不在当前节点的管理范围内，则 <strong> 向客户端返回 moved 重定向异常</strong> </p>
<p>　5. 客户端接收到节点返回的结果，如果是 moved 异常，则 <strong> 从 moved 异常中获取目标节点的信息</strong> </p>
<p>　6. 客户端向目标节点发送命令，获取命令执行结果<img src="https://api2.mubu.com/v3/document_image/ea429ae5-bc25-492b-b584-303d4c5c7e76-12259280.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 集合</title>
    <url>/2021/11/10/Java%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h5 id="集合的继承关系"><a href="# 集合的继承关系" class="headerlink" title="集合的继承关系"></a>集合的继承关系</h5><p>Map 接口和 Collection 接口是所有集合框架的父接口，常见的 Java 集合类主要有：</p>
<ul>
<li>Collection 接口的子接口包括：Set 接口和 List 接口</li>
<li>Map 接口的实现类：HashMap、TreeMap、Hashtable、ConcurrentHashMap</li>
<li>Set 接口的实现类：HashSet、TreeSet</li>
<li>List 接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector</li>
</ul>
<span id="more"></span>
<p><img src="https://api2.mubu.com/v3/document_image/8ad51b9d-9d66-4629-aa4e-1705a6d460af-12259280.jpg" alt="img"></p>
<h5 id="线程安全的集合"><a href="# 线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h5><p>　vector、stack(继承了 stack)、hashtable，这几个集合类往往是在一些重要方法中使用了 synchronized 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stack:</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">vector:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="fail-fast 机制"><a href="#fail-fast 机制" class="headerlink" title="fail-fast 机制"></a>fail-fast 机制</h5><p>　多个线程同时访问集合时，如果有一个线程尝试修改集合结构，就有可能触发 fail-fast 机制，例如在某一时刻，线程 A 在遍历集合，线程 B 修改集合元素个数，这是会抛出并发修改异常 ConcurrentModificationException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>原因：如果集合结构发生变化，modCount 就会改变，每当迭代器使用 next()方法遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。<img src="https://api2.mubu.com/v3/document_image/08efb92d-2a18-4195-a121-8e6a4575e0bd-12259280.jpg" alt="img"></p>
<p>　</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (expectedModCount != ArrayList.<span class="keyword">this</span>.modCount)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>　1. 在遍历过程中，所有涉及到改变 modCount 值得地方全部加上 synchronized（效率会变低）</p>
<p>　2. 使用 CopyOnWriteArrayList(写时复制思想)来替换 ArrayList</p>
<h5 id="什么是 CopyOnWrite 容器"><a href="# 什么是 CopyOnWrite 容器" class="headerlink" title="什么是 CopyOnWrite 容器"></a>什么是 CopyOnWrite 容器</h5><p>　CopyOnWrite 容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。好处是可以对 CopyOnWrite 容器进行并发读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>　<strong>CopyOnWriteArrayList</strong>读取时不加锁，只有 <strong> 增删改时加锁</strong></p>
<p>　注意：读不需要加锁，如果读的时候有多个线程正在向 CopyOnWriteArrayList 添加数据，读还是会读到旧的数据，因为开始读的那一刻已经确定了读的对象是旧对象。</p>
<h6 id="CopyOnWrite 的缺点"><a href="#CopyOnWrite 的缺点" class="headerlink" title="CopyOnWrite 的缺点"></a>　CopyOnWrite 的缺点</h6><p>　内存占用问题和数据一致性问题</p>
<ol>
<li><p>内存的使用 <br> 由于 CopyOnWriteArrayList 使用了“写时复制”，所以在进行写操作的时候，<strong> 内存里会同时存在两个 array 数组 </strong>，如果数组内存占用的太大，那么可能会<strong> 造成频繁 GC</strong>, 所以 CopyOnWriteArrayList 并不适合大数据量的场景。</p>
</li>
<li><p>数据一致性 <br> CopyOnWriteArrayList<strong> 只能保证数据的最终一致性，不能保证数据的实时一致性</strong>——因为读操作读到的数据只是一份快照。所以如果希望写入的数据可以立刻被读到，那 CopyOnWriteArrayList 并不适合</p>
</li>
</ol>
<h5 id="CopyOnWriteArrayList 和 vector 的区别"><a href="#CopyOnWriteArrayList 和 vector 的区别" class="headerlink" title="CopyOnWriteArrayList 和 vector 的区别"></a>CopyOnWriteArrayList 和 vector 的区别 </h5><p>　他们都是并发安全的，但是<strong> 性能上存在一些差异</strong>。</p>
<p>　Vector 是增删改查方法都加了 synchronized，保证同步，但是每个方法执行的时候都要去获取锁，性能就会大大降低</p>
<p>　CopyOnWriteArrayList 只是在增删改上加 ReentrantLock 独占锁，但是读操作不加锁，支持并发读，因此它适合读多写少的场景</p>
<h5 id="ArrayList- 和 -LinkedList"><a href="#ArrayList- 和 -LinkedList" class="headerlink" title="ArrayList 和 LinkedList"></a>ArrayList 和 LinkedList</h5><p>　数据结构：ArrayList 底层是 <strong> 动态数组 </strong>，LinkedList 底层是<strong> 双向链表 </strong><br>　随机访问效率：ArrayList 实现了<strong>RandomAccess</strong> 接口，只要 List 集合实现了这个接口就能支持快速随机访问。ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找<br>　增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。<br>　内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。<br>　线程安全：二者都不保证线程安全；</p>
<p>　各自的优缺点：</p>
<ul>
<li>ArrayList<ul>
<li>实现了 RandomAccess 接口，随机访问快，在末尾添加元素复杂度不高。</li>
<li>在非末尾处增删元素涉及到元素的移动，比较耗费性能。</li>
</ul>
</li>
<li>LinkedList<ul>
<li>增删快，不涉及元素移动。查找慢，要从头开始遍历</li>
</ul>
</li>
</ul>
<h5 id="HashSet 原理"><a href="#HashSet 原理" class="headerlink" title="HashSet 原理"></a>HashSet 原理</h5><p>　HashSet 是基于 HashMap 实现的，HashSet 的值存放于 HashMap 的 key 上，HashMap 的 value 统一为 PRESENT，HashSet 不允许重复的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值</span></span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="JDK1-7 和 JDK1-8 中 ArrayList 的区别"><a href="#JDK1-7 和 JDK1-8 中 ArrayList 的区别" class="headerlink" title="JDK1.7 和 JDK1.8 中 ArrayList 的区别"></a>JDK1.7 和 JDK1.8 中 ArrayList 的区别</h5><p>　JDK1.7 的时候是初始化就创建一个容量为 10 的数组，JDK1.8 后是初始化先创建一个空数组，第一次 add 时才扩容为 10（类似于饿汉式和懒汉式）</p>
<h5 id="ArrayList 扩容"><a href="#ArrayList 扩容" class="headerlink" title="ArrayList 扩容"></a>ArrayList 扩容</h5><p>　1.5 倍扩容，把原数组的数据复制到新数组中，再把指向原数组的地址换到新数组<img src="https://api2.mubu.com/v3/document_image/379d8270-a408-48e4-9b20-884d4f7c89f4-12259280.jpg" alt="img"></p>
<h6 id="add-E-e- 方法"><a href="#add-E-e- 方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h6><p>　添加元素前会先判断数组是否为空，如果为空，则创建一个长度为 10 的空数组，然后在把所添加的元素加入到数组中。如果不为空，则判断集合大小是否超出数组的长度，判断完长度后决定是否扩容。</p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><h6 id="成员变量"><a href="# 成员变量" class="headerlink" title="成员变量"></a>成员变量</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认初始容量 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">// 最大容量 2^30</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; <span class="comment">// 转化为红黑树的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; <span class="comment">// 树转链表的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; <span class="comment">//  转化为红黑树的阈值</span></span><br></pre></td></tr></table></figure>
<p>链表长度达到 8 会尝试转成红黑树，但是如果此时容量小于 64 时会先扩容，而不是转成红黑树</p>
<p><img src="https://api2.mubu.com/v3/document_image/8117cd3c-3c8b-4042-a8d1-a0dc61d8d81c-12259280.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>; <span class="comment">// 先将传入容量 -1</span></span><br><span class="line">    <span class="comment">// 得到 2 的幂次方 -1  也就是二进制全为 1 的数</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 返回 n + 1  即 2 的幂次方</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="为什么 HashMap 的容量是 2 的幂次方"><a href="# 为什么 HashMap 的容量是 2 的幂次方" class="headerlink" title="为什么 HashMap 的容量是 2 的幂次方"></a>为什么 HashMap 的容量是 2 的幂次方 </h6><p>　1. 根据 key 的 hash 值寻找对应的哈希桶时，可以<strong> 用位运算替代取模运算 </strong>，<strong> 更加高效</strong>，即<code>p = tab[i = (n - 1) &amp; hash]</code></p>
<p>　2. 扩容后，用 hash 与 oldCap 做与运算用于判断元素的在数组中的位置是否需要移动 <code>e.hash &amp; oldCap == 1</code> 表示需要移动，否则不移动，其中 oldCap 是 2 的幂次方，因此二进制表示时候只有最高位为 1</p>
<h6 id="为什么扰动函数用 key-hashcode- 的高低 16 位做异或运算？"><a href="# 为什么扰动函数用 key-hashcode- 的高低 16 位做异或运算？" class="headerlink" title="为什么扰动函数用 key.hashcode()的高低 16 位做异或运算？"></a>为什么扰动函数用 key.hashcode()的高低 16 位做异或运算？</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　hashcode 这个 32bit 的散列值是不能直接拿来用的，使用之前还要先做 <strong> 对数组的长度取模运算 </strong>，得到的余数才能用来访问数组下标。源码中模运算是<code>(n - 1) &amp; hash</code> 完成的，实际上就是散列值的高位全部归 0，只保留低位的值 (实际上就是取低位)，但这时候问题就来了，就算散列值分布再松散，要是只取最后几位的话，碰撞机率会很大，更严重的情况是<strong> 如果散列本身做得不好，分布上成等差数列的漏洞 </strong>，恰好使最后几个低位呈现规律性重复，<strong> 就很容易发生哈希冲突。</strong></p>
<p>右移 16 位，正好是 32bit 的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，<strong>以此来加大低位的随机性</strong></p>
<h6 id="put 过程"><a href="#put 过程" class="headerlink" title="put 过程"></a>put 过程 </h6><p>　1. 判断键值对数组 table[i] 是否为空或为 null，是的话 resize()进行扩容；传入 key.hashcode()重新计算哈希值 (高低 16 位异或)，然后(n - 1) &amp;hash 确定桶的位置<br> 　2. 如果 table[i]==null，直接新建节点添加，转向 6，如果 table[i]！=null，转向 3<br>　3. 判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向 4，这里的相同指的是 hashCode 以及 equals<br>　4. 判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向 5<br>　5. 遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可<br>　6. 插入成功后，判断键值对数量是否超过最大容量如果超过，进行扩容</p>
<h6 id="get 过程"><a href="#get 过程" class="headerlink" title="get 过程"></a>get 过程 </h6><p>　1 通过 hash &amp; (table.length - 1) 获取该 key 对应的数据节点的 hash 槽 <br>　2 判断首节点是否为空, 为空则直接返回空<br>　3 再判断首节点.key 是否和目标值相同, 相同则直接返回(首节点不用区分链表还是红黑树)<br>　4 首节点.next 为空, 则直接返回空<br>　5 首节点是树形节点, 则进入红黑树数的取值流程, 并返回结果<br>　6 进入链表的取值流程, 并返回结果<br> 扩容扩展后 Node 对象的位置要么在原位置，要么移动到 原始位置 + 增加的数组</p>
<h6 id="HashMap 在并发编程环境下有什么问题"><a href="#HashMap 在并发编程环境下有什么问题" class="headerlink" title="HashMap 在并发编程环境下有什么问题?"></a>HashMap 在并发编程环境下有什么问题?</h6><ul>
<li>JDK1.7 中，并发执行扩容操作可能引起的链表死循环问题</li>
<li>多线程 put 的时候可能导致元素丢失</li>
<li>在 JDK1.8 中，在并发执行 put 操作时会发生数据覆盖的情况</li>
</ul>
<p>　数据覆盖：A、B 都在进行 put 操作，并且 hash 函数计算出的插入下标是相同的，当线程 A 由于时间片耗尽导致被挂起，而线程 B 得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程 A 获得时间片，由于之前已经进行了 hash 碰撞的判断，所有此时不会再进行判断，而是直接进行插入</p>
<h6 id="转化成红黑树的阈值为什么是 8"><a href="# 转化成红黑树的阈值为什么是 8" class="headerlink" title="转化成红黑树的阈值为什么是 8"></a>转化成红黑树的阈值为什么是 8</h6><p>　红黑树节点大小约为链表节点的 2 倍，在节点太少时，红黑树的查找性能优势并不明显，付出 2 倍空间的代价作者觉得不值得。</p>
<p>　理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中节点个数为 8 时的概率为 $6*10^{-7}$，这个概率足够低了，并且到 8 个节点时，红黑树的性能优势也会开始展现出来，因此 8 是一个较合理的数字<img src="https://api2.mubu.com/v3/document_image/2576d75c-aff8-4c27-989b-294c513ca84a-12259280.jpg" alt="img"></p>
<h6 id="HashMap- 与 -HashTable- 有什么区别？"><a href="#HashMap- 与 -HashTable- 有什么区别？" class="headerlink" title="HashMap 与 HashTable 有什么区别？"></a>HashMap 与 HashTable 有什么区别？</h6><p>　底层数据结构：JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</p>
<p>　初始容量和扩容：</p>
<p> 　①创建时如果不指定容量初始值，Hashtable <strong>默认的初始大小为 11</strong>，扩充后容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为 16，扩充后容量变为原来的 2 倍。<img src="https://api2.mubu.com/v3/document_image/377e3347-66e6-4b80-bcc4-830960567b37-12259280.jpg" alt="img"></p>
<p>　②创建时如果给定了容量初始值，那么 Hashtable 会直接使用传入的参数ｎ，而 HashMap 会将其扩充为最接近ｎ的 2 的幂次方大小，比如 n=13 会自动扩充为 $2^4=16$</p>
<p>　线程安全：HashMap 是非线程安全的，HashTable 是线程安全的，因为 HashTable 内部的方法基本都经过 synchronized 修饰，<strong>这意味着 HashTable 的效率会比 HashMap 低</strong></p>
<p>　null 键和 null 值：HashMap 中，null 可以作为键，<strong>这样的键只有一个 </strong>，可以有一个或多个键所对应的值为 null，HashTable <strong> 不支持 null 键和 null 值</strong></p>
]]></content>
      <categories>
        <category>Java基础知识</category>
      </categories>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>跨平台性、编译型语言、解释型语言</title>
    <url>/2021/10/17/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h5 id="跨平台性是什么意思？"><a href="# 跨平台性是什么意思？" class="headerlink" title="跨平台性是什么意思？"></a>跨平台性是什么意思？</h5><p>&emsp;&emsp; 要知道，不同操作系统支持的函数、数据类型都可能不同，所以基于某个操作系统下编写的源代码一般是不能直接拿到另一个操作系统下编译的。注意 <strong> 我们所说的跨平台指的是源代码跨平台，而不是解释器跨平台</strong>。</p>
<span id="more"></span>
<h5 id="为什么说 Java 是跨平台性的语言？"><a href="# 为什么说 Java 是跨平台性的语言？" class="headerlink" title="为什么说 Java 是跨平台性的语言？"></a>为什么说 Java 是跨平台性的语言？</h5><p>&emsp;&emsp; 跨平台性是指使用 Java 语言编写的程序，经过一次编译后，可以在不同操作系统上运行。其原理就是 Java 程序是通过 Java 虚拟机在操作系统上运行的，只要该操作系统安装了对应的 Java 虚拟机，这个系统就可以运行 Java 程序。<br>&emsp;&emsp; 也就是说，Java 程序只需要跟虚拟机打交道，与操作系统的交互都由虚拟机来负责。</p>
<h5 id="编译型语言、解释型语言、混合型语言"><a href="# 编译型语言、解释型语言、混合型语言" class="headerlink" title="编译型语言、解释型语言、混合型语言"></a>编译型语言、解释型语言、混合型语言</h5><p>&emsp;&emsp; 计算机只能识别二进制指令，我们学习的 Java、C++、Python 都是高级语言，高级语言程序代码带运行之前要将源代码转换成二进制指令，也就是机器码，机器码是 CPU 可识别的硬件层面的代码。<br>&emsp;&emsp; 那么，到底在何时将源代码转换成机器码呢? 根据转换时机的不同，便有了不同类型的语言。</p>
<ul>
<li>编译型语言：提前将源代码通过 <strong> 编译器 </strong> 一次性全部转换成机器码，也就是生成一个可执行程序，比如 windows 下的.exe 文件，常见的编译型语言有 C、C++、Go、汇编语言<ul>
<li>优点：可以脱离开发环境运行，比如 window 下，通过编译后生成.exe 可执行文件，可执行文件所包含的就是机器码，只要拥有了可执行程序就可以到处运行，不需要再重新编译了（不需要源代码和编译器了），可以做到 <strong> 一次编译，无限次运行</strong>。</li>
<li>缺点：可移植性差，因为不同操作系统的可执行文件几乎不兼容。</li>
</ul>
</li>
<li>解释型语言：通过 <strong> 解释器 </strong> 一边执行一边转换，<strong>解释型语言不会生成可执行程序</strong>，常见的解释型语言有 Python、Matlab<ul>
<li>优点: 可移植性好，因为有了中间层：<strong>解释器</strong>，官方针对不同操作系统开发不同的解释器，使得同样的源代码在不同操作系统下的执行结果是完全相同的。故解释型语言天生具有良好的可移植性。</li>
<li>缺点：相对编译型语言来说，解释型语言执行效率比较慢，甚至存在量级上的差距。</li>
</ul>
</li>
<li>混合型语言：半编译半解释，先将源代码转换成一种中间文件（在 Java 中就是字节码文件），然后再将中间文件拿到虚拟机中执行。常见的有 Java、C#</li>
</ul>
<p>&emsp;&emsp; 当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p>
<p>&emsp;&emsp;&emsp;&emsp; 对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是 <strong> 闭源 </strong> 的。</p>
<p>&emsp;&emsp;&emsp;&emsp; 对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是 <strong> 开源 </strong> 的</p>
<p>&emsp;&emsp; 编译型语言和解释型语言的执行流程如下图所示：</p>
<p><img src="https://api2.mubu.com/v3/document_image/74a0fec7-97de-41a0-82e6-b8eda78fb014-12259280.jpg" alt="编译型语言和解释型语言的执行流程"></p>
<p>&emsp;&emsp; 有次面试被问到过<strong>Java 和 Python 的区别</strong>，当时只答了一些语法层面，还有强类型语言弱类型语言的东西，包括垃圾回收机制（Python 也是有自动垃圾回收的，而且用的是引用计数法）。面试官说我理解得不够深刻，我想他应该是想让我从这个层面来说吧。</p>
]]></content>
      <tags>
        <tag>语言类型的差异</tag>
      </tags>
  </entry>
  <entry>
    <title>python 批量修改文件后缀名</title>
    <url>/2021/10/12/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_files_list</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    实现遍历 dir 目录下, 所有文件 (包含子文件夹的文件)</span></span><br><span class="line"><span class="string">    :param dir: 指定文件夹目录 </span></span><br><span class="line"><span class="string">    :return: 包含所有文件的列表 -&gt;list</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># parent: 父目录, filenames: 该目录下所有文件夹,filenames: 该目录下的文件名 </span></span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;E:\test&quot;</span></span><br><span class="line">filelist = get_files_list(path)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filelist:</span><br><span class="line">    portion = os.path.splitext(filename)  <span class="comment"># portion 为名称和后缀分离后的列表 </span></span><br><span class="line">    <span class="keyword">if</span> portion[<span class="number">1</span>] ==<span class="string">&quot;.bmp&quot;</span>:</span><br><span class="line">        newname = portion[<span class="number">0</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(filename)  <span class="comment"># 打印出要更改的文件名 </span></span><br><span class="line">        os.chdir(path)</span><br><span class="line">        os.rename(filename, newname)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 索引</title>
    <url>/2021/11/12/MySQL%E7%B4%A2%E5%BC%95/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h6 id="索引数据结构演化"><a href="# 索引数据结构演化" class="headerlink" title="索引数据结构演化"></a>索引数据结构演化 </h6><p>　有序数组：有序数组可以使用<strong> 二分查找 </strong>，有序数组的等值查询和比较查询效率非常高，但是更新数据的时候会出现一个问题，可能要挪动大量的数据（改变 index），所以只适合<strong> 存储静态的数据</strong></p>
<p>　链表：支持频繁的修改，不需要挪动大量数据。但如果是单链表，查找效率还是不够高。</p>
<span id="more"></span>
<p>　二叉查找树：既能够 <strong> 实现快速查找，又能够实现快速插入 </strong>。但是有一个缺陷：<strong> 在极端情况下，树会退化成链表。</strong>因为左右子树深度差太大，也就是这棵树 <font color="red"> 不够平衡</font>。因此，可以使用平衡二叉树（AVL）。</p>
<p>　平衡二叉树：<strong>左右子树深度差绝对值不能超过 1</strong>，解决了 <strong> 二叉查找树退化为近似链表的缺点 </strong>，但是平衡度要求严格，因此每次插入 / 删除结点的时候都需要通过左旋右旋对树进行调整使之平衡，<strong> 这对性能影响很大 </strong>。因此，可以考虑使用<font color="red"> 弱平衡树：红黑树</font></p>
<p>　红黑树：<strong>红黑树确保没有一条路径会比其它路径长出两倍 </strong>，因此红黑树是一种<strong> 弱平衡二叉树 </strong>（<strong> 因此在相同的节点情况下，AVL 树的高度低于红黑树）</strong>，相对于要求严格的 AVL 树来说，它的旋转次数少，<strong>对于插入，删除操作较多的情况下，红黑树性能更好</strong></p>
<p>　以上都是二叉树，MySQL 用树的结构来存储索引的时候，访问一层节点就要跟磁盘之间发生一次 IO。InnoDB 操作磁盘的最小的单位是一页，大小是 16K，那么，一个树的节点就是 16K 的大小。如果每个节点存储的数据太少，从索引中找到我们需要的数据，就要访问更多的节点，意味着跟磁盘交互次数就会过多。因此，<strong>可以使用多叉树 </strong>。<strong> 因为分叉数越多，树的深度就会减少</strong></p>
<p>　多路平衡查找树（ B 树）：B 树每个结点存储着 <strong> 键值、数据地址、节点引用</strong><img src="https://api2.mubu.com/v3/document_image/be696c86-796d-462e-87ee-ed412e9cf721-12259280.jpg" alt="img"></p>
<p>　B+ 树：B+Tree 的非叶子结点都不会存储数据，只有叶子节点才存储数据。搜索到关键字不会直接返回，会到最后一层的叶子节点。比如我们搜索 id=28，虽然在第一层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜索，一直到叶子节点</p>
<p><img src="https://api2.mubu.com/v3/document_image/da9ecc92-6d49-4df5-afbe-8925a1e3621f-12259280.jpg" alt="img"></p>
<h6 id="B- 树的特点"><a href="#B- 树的特点" class="headerlink" title="B+ 树的特点"></a>B+ 树的特点</h6><p>　1.B Tree 能解决的问题，它都能解决 （每个节点存储更多关键字；路数更多）<br>　2. 扫库、扫表能力更强（如果要进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵 B+Tree 拿到所有的数据）</p>
<p>　3. 非叶子结点不保存数据，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多</p>
<p>　4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）<br>　5. 效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的）</p>
<h6 id="MySQL 索引类型"><a href="#MySQL 索引类型" class="headerlink" title="MySQL 索引类型"></a>MySQL 索引类型</h6><p>　索引类型有三种，普通索引、唯一索引（主键索引是特殊的唯一索引）、全文索引。</p>
<p>　唯一索引：<strong>键值不能重复</strong>。主键索引是一种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空</p>
<p>　全文索引：针对比较大的数据，比如我们存放的是消息内容，有几 KB 的数据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如 char、varchar、text</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>方法调用的本质</title>
    <url>/2021/11/13/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<p>每一个变量都有两种类型：静态类型（Static Type）和实际类型（Actual Type），例如下面代码中，Person 为变量 person 的静态类型，Student 为实际类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>区别如下：</p>
<ul>
<li>静态类型：引用变量的类型，在 <strong> 编译期确定，无法改变</strong></li>
<li>实际类型：实例对象的类型，在编译期无法确定，需在 <strong> 运行期确定，可以改变</strong></li>
</ul>
<p>Java 前端编译的产物是字节码，字节码中所有的方法调用都是使用符号引用，如图，#1 #2 #3 表示符号引用在常量池中的索引号，根据这个索引号检索常量表，可以查到最终表示的是一个字符串字面量，例如 func:()V，这个就是方法的符号引用。符号引用（Symbolic References）是一个用来 <strong> 无歧义地标识一个实体（例如方法 / 字段）的字符串，在运行期会翻译为直接引用 </strong>（Direct Reference）。对于方法来说，就是方法的入口地址。通过这个符号引用，Java 虚拟机就可以翻译出该方法的直接引用。但是，<strong> 同一个符号引用，运行时翻译出来的直接引用可能是不同的</strong>，为什么会这样呢？</p>
<p><img src="https://api2.mubu.com/v3/document_image/df80dc3b-0b6a-4a56-9960-4a827c99c206-12259280.jpg" alt="img"></p>
<p>Java 中方法选择的三个步骤：</p>
<ul>
<li><p>步骤 1：生成符号引用（编译时）：1. 方法的符号引用在编译期确定，并固化到字节码中方法调用指令的参数中</p>
</li>
<li><p>步骤 2：解析（类加载时）：为什么静态方法、私有实例方法、实例构造器、父类方法以及 final 修饰这五种方法（对应的关键字： static、private、<init>、super、final）可以在编译期确定版本呢？<strong>因为无论运行时加载多少个类，这些方法都保证唯一的版本</strong>, 比如 private 只在本类中可见，final 修饰的方法不能被重写</init></p>
</li>
<li><p>既然可以确定方法的版本，虚拟机在处理 invokestatic、invokespecial、invokevirtual(final)时，就可以 <strong> 提前将符号引用转换为直接引用，不必延迟到方法调用时确定</strong>，具体来说，是在类加载的解析阶段完成转换的。</p>
</li>
<li><p>步骤 3：动态分派（类使用时）</p>
<ul>
<li><p>invokevirtual 指令</p>
</li>
<li><p>虚拟机为每个类生成 <strong> 虚方法表 vtable</strong>（virtual method table），类中声明的方法的入口地址会按固定顺序存放在虚方法表中；虚方法表还会继承父类的虚方法表，顺序与父类保持一致，子类新增的方法按顺序添加到虚方法末尾（这以 Java 单继承为前提）；<strong>若子类重写父类方法，则重写方法位置的入口地址修改为子类实现；</strong></p>
</li>
<li><p>1）类加载解析阶段：解析类的继承关系，生成类的虚方法表 （包含了这个类型所有方法的入口地址）。举个例子，有 Class B 继承与 Class A，并重写了 A 中的方法：<img src="https://api2.mubu.com/v3/document_image/ea79dee7-15ce-4c6e-8850-76fc698675e7-12259280.jpg" alt="img"></p>
</li>
<li><p>Object 是所有类的父类，所有 <strong> 每个类的虚方法表头部都会包含 Object 的虚方法表 </strong>。另外，B 重写了 A#printMe()，所以对应位置的<strong> 入口地址方法被修改为 B 重写方法的入口地址。</strong></p>
</li>
<li><p>需要注意的是，被<strong>final、static 或 private 修饰的方法不会出现在虚方法表中</strong>，因为这些方法无法被继承重写。</p>
</li>
<li><p>2）调用阶段（动态分派）：解析阶段生成虚方法表后，每个方法在虚方法表中的索引是固定的，这是不会随着实际类型变化影响的。调用方法时，<strong>首先根据变量的实际类型获得对应的虚方法表 </strong>（包含了这个类型所有方法的入口地址），然后<strong> 根据索引找到方法的入口地址</strong></p>
</li>
</ul>
</li>
</ul>
<p>总结：</p>
<ul>
<li><strong>1. 方法调用的本质是根据方法的符号引用确定方法的直接引用（入口地址）</strong>的过程，一共需要经过（编译时）生成符号引用、（类加载时）解析、（调用时）动态分派三个步骤</li>
<li>2.invokestatic &amp; invokespecial 指令在（类加载时）解析时根据静态类型完成转换</li>
<li>3.invokevirtual &amp; invokeinterface 在（调用时）根据实际类型，查找 vtable &amp; itable 完成转换</li>
<li>4. 重载其实是编译器的语法特性与多态无关，对编译时符号引用生成有影响，在运行时已经没有影响了；重写是多态的基础，虚拟机通过 vtable &amp; itable 来支持虚方法的方法选择。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>RandomAccess 接口有什么作用？</title>
    <url>/2021/11/12/RandomAccess%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/RandomAccess%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>ArrayList 实现了 RandomAccess 接口，而 LinkedList 没有，这两者有什么区别？</p>
<span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure>
<p> 从源码中可以看到，RandomAccess 接口中是空的，那这代表什么含义呢？红色方框中可以看到，for 循环遍历比迭代器遍历速度要快。</p>
<p><img src="https://api2.mubu.com/v3/document_image/c7a77c31-ec6e-4e43-8a09-17e13002b37a-12259280.jpg" alt="img"></p>
<p> 从这里可以看到，binarySearch 选择二分查找方式时，会先判断 list 是否实现了 RandomAccess 接口，如果实现了就用 for 循环遍历，否则使用迭代器遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 以下是 indexedBinarySearch 方法和 iteratorBinarySearch 方法的源码 </p>
<p><img src="https://api2.mubu.com/v3/document_image/bac7b699-61d2-47b4-b9a2-6eb640f07572-12259280.jpg" alt="img"></p>
<p><img src="https://api2.mubu.com/v3/document_image/19cb6789-f0d7-4107-aee0-760a91209063-12259280.jpg" alt="img"></p>
<p> 可以发现，实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器。我们分别使用 for 循环方式和迭代器方式对 ArrayList 和 LinkedList 进行遍历，然后计算遍历时间。</p>
<p><img src="https://api2.mubu.com/v3/document_image/26db1bfa-d07b-4439-9f78-75164b9cd149-12259280.jpg" alt="img"></p>
<p> 从图中可以看出，<font color="red">ArrayList 用 for 循环遍历比 iterator 迭代器遍历快，LinkedList 用 iterator 迭代器遍历比 for 循环遍历快 </font>, 因此，在遍历 list 的时候，我们可以先判断是否实现了 RandomAccess 接口，如果实现了该接口，就使用 for 循环方式遍历 </p>
<p> 注意：<strong> 增强 for 循环底层也是采用迭代器实现 </strong>，所以增强 for 循环和迭代器遍历是一回事 </p>
]]></content>
      <tags>
        <tag>Java基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h5 id="计算机网络体系结构"><a href="# 计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构 </h5><p> 应用层：应用软件都是在应用层实现。那么，当两个不同设备的应⽤需要通信的时候，应⽤就把应⽤数据传给下⼀层，也就是传输层。主要协议有 HTTP,DNS,SMTP</p>
<span id="more"></span>
<p>传输层：主要任务是负责向两台主机中 <strong> 进程之间的通信 </strong> 提供数据传输服务, 主要协议有 TCP/UDP</p>
<ul>
<li>TCP：传输层控制协议（Transmission Control Protocol），<strong>提供面向连接的，可靠的 </strong> 数据传输服务，传输单位是报文段</li>
<li>UDP：用户数据报协议（User Datagram Protocol），提供 <strong> 无连接的、尽最大努力交付的 </strong> 数据传输服务，传输单位是用户数据报</li>
</ul>
<p>如果传输层的数据包大小超过 TCP 最大报文段长度 （MSS），就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重传分块，而不是整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP 段（TCP Segment）</p>
<p>网络层：负责为网络中的 <strong> 不同主机提供通信服务</strong>。</p>
<p>数据链路层：将网络层交下来的 IP 数据报封装成帧，并且加上一些必要的控制信息，如差错控制等，传输单位是帧</p>
<p>物理层：把数据包转换成电信号，让其可以在物理介质中传输</p>
<p>注意，一些物理媒体，比如光纤、同轴电缆，这些并不属于物理层协议内，而是在物理层协议下面，也可以当作是第 0 层</p>
<p><img src="https://api2.mubu.com/v3/document_image/f07bf730-733f-45e6-ad39-5856312e7165-12259280.jpg" alt="img"></p>
<p>为什么计算机网络要分为层模型？</p>
<p>　①各层之间是独立的。某一层可以使用其下一层提供的服务而不需要知道服务是如何实现的</p>
<p>　②灵活性好。当某一层发生变化时，只要其接口关系不变，则这层以上或以下的各层均不受影响　</p>
<p>　③结构上可分割开。各层可以采用最合适的技术来实现</p>
<p>　④易于实现和维护</p>
<p>　⑤能促进标准化工作</p>
<h5 id="数据链路层"><a href="# 数据链路层" class="headerlink" title="数据链路层"></a>数据链路层 </h5><h6 id="使用点对点信道的数据链路层"><a href="# 使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a> 使用点对点信道的数据链路层 </h6><p>　数据链路层使用的信道主要有：点对点信道(PPP 协议) 和广播信道(CSMA/CD 协议)</p>
<p>　数据链路层的三个基本问题：封装成帧、透明传输和差错检测。</p>
<p>　封装成帧：给帧加上头部和尾部来进行帧定界，也就是帧开始符 (SOH) 和帧结束符(EOT)</p>
<p><img src="https://api2.mubu.com/v3/document_image/99239b5e-507e-482a-a063-6252b68ef41f-12259280.jpg" alt="img"></p>
<p>　<img src="https://api2.mubu.com/v3/document_image/ce857b60-d059-42bc-8067-1f97ab5bfa67-12259280.jpg" alt="img"></p>
<p>　透明传输：如果传输的数据中二进制代码刚好出现了和 SOH 和 EOT 这种控制字符一样，链路层就会 <strong> 错误地“找到帧的边界”，而把剩下的那部分数据丢弃</strong>。</p>
<p><img src="https://api2.mubu.com/v3/document_image/3bef30ab-7cb0-49d1-a5bf-a75b81f10202-12259280.jpg" alt="img"></p>
<p>　为了解决透明传输问题，就必须使得数据中出现控制字符 SOH 和 EOT 在接收端不会被解释为控制字符。具体做法：字节填充法，也就是在控制字符前面插入转义字符。</p>
<p><img src="https://api2.mubu.com/v3/document_image/2fc163e2-726e-428e-93f8-bcfd75944702-12259280.jpg" alt="img"></p>
<p>　差错检测：循环冗余检验 CRC(Cyclic Redundancy Check)技术，就是双方协商一个固定的除数 P，在数据后面添加 n 位 (n 就是 P 多项式的最高幂次) 的冗余检错码，构成一个帧发送出去，如果数据 M=101001，除数 P=1101，写成多项式就是 $P=X^{3}+X^{2}+1$，得到余数 001，在 M 后添加 001 得到最终发出去的帧序列：101001001，接收端收到帧序列后，除以除数 P，得到余数 R</p>
<ul>
<li>$R = 0$，判定这个帧在传输过程过没有出现差错，接受。</li>
<li>$R \ne 0$，出现差错（但是不知道是哪一位或者哪几位出现了差错），丢弃该帧。</li>
</ul>
<p><img src="https://api2.mubu.com/v3/document_image/00f01da9-e655-4f81-98e7-e3e49ea293c7-12259280.jpg" alt="img"></p>
<p>　有了 CRC 冗余校验就做到帧的无差错接收，也就是可做到不出现比特差错。</p>
<p>　但是有一种情况是帧差错：帧丢失、帧重复或者帧失序，因此在 CRC 的基础上，增加帧编号、确认和重传机制。</p>
<ul>
<li>对于 <strong> 通信质量较差 </strong> 的无线传输链路，链路层协议使用 <strong> 确认和重传 </strong> 机制，向上提供可靠传输的服务。</li>
<li>对于 <strong> 通信质量较好 </strong> 的有线传输链路，链路层协议 <strong> 不使用 </strong> 确认和重传机制，如果出现了差错并且需要进行改正，改正差错的任务由上层协议（例如 TCP 协议）来完成</li>
</ul>
<h6 id="使用广播信道的数据链路层"><a href="# 使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h6><p>　局域网特点：地理范围和站点数目有限，拓朴结构主要有：星形、环形、总线形</p>
<h6 id="CSMA-CD 协议"><a href="#CSMA-CD 协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h6><p>　总线上只要有一台计算机在发送数据，总线的传输资源就被占用。因此，在同一时间只能允许一台计算机发送数据，否则各计算机之间就会互相干扰，使得所发送数据被破坏。因此，如何协调总线上各计算机的工作就是以太网要解决的一个重要问题。它使用的协议是 CSMA/CD，意思是载波监听多点接入 / 碰撞检测(Carrier Sense Multiple Access with Collision Detection)</p>
<p>　“多点接入”就是说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。协议的实质是“载波监听”和“碰撞检测”。<br>　“载波监听”指在发送前，还是在发送中，每个站都必须不停地检测信道。在发送前检测信道，是为了获得发送权。如果检测出已经有其他站在发送，则自己就暂时不许发送数据，必须要等到信道变为空闲时才能发送。在发送中检测信道，是为了及时发现有没有其他站的发送和本站发送的碰撞。这就称为碰撞检测。<br>　“碰撞检测”也就是“边发送边监听”，即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。当几个站同时在总线上发送数据时，总线上的信号电压变化幅度将会增大（互相叠加)。当适配器检测到的信号电压变化幅度超过阈值时，就认为产生了碰撞，适配器就要停止发送数据，以免浪费网络资源，然后等待一段随机时间后再次发送。</p>
<h6 id="帧格式"><a href="# 帧格式" class="headerlink" title="帧格式"></a>帧格式</h6><p>　以太网帧使用 MAC 地址来作为标识符，MAC 帧的头部是 18B，以太网 MAC 帧的长度是 64-1518B，因此数据部分是 46-1500B，当数据部分不足 46B 时，MAC 子层会在数据字段的后面加入一个整数字节的填充字段。</p>
<p><img src="https://api2.mubu.com/v3/document_image/09a1a4d6-0775-4cde-8e3a-bebde81009ce-12259280.jpg" alt="img"></p>
<h5 id="网络层"><a href="# 网络层" class="headerlink" title="网络层"></a>网络层 </h5><h6 id="分类的 IP 地址"><a href="# 分类的 IP 地址" class="headerlink" title="分类的 IP 地址"></a> 分类的 IP 地址</h6><p>　</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>网络类别</th>
<th>第一个可指派的网络号</th>
<th>最后一个可指派的网络号</th>
<th>每个网络中的最大主机数</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1</td>
<td>126</td>
<td>16777214</td>
</tr>
<tr>
<td>B</td>
<td>128.1</td>
<td>191.255</td>
<td>65534</td>
</tr>
<tr>
<td>C</td>
<td>192.0.1</td>
<td>223.255.255</td>
<td>254</td>
</tr>
</tbody>
</table>
</div>
<h6 id="IP 地址与物理地址的区别？"><a href="#IP 地址与物理地址的区别？" class="headerlink" title="IP 地址与物理地址的区别？"></a>IP 地址与物理地址的区别？</h6><p>　从层次的角度看，物理地址是数据链路层和物理层使用的地址，而 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。</p>
<p><img src="https://api2.mubu.com/v3/document_image/af7f7649-96cf-47a3-89a7-b00ba2b2a94e-12259280.jpg" alt="img"></p>
<p>如果有以下拓扑结构的网络，主机 $H_1$ 与主机 $H_2$ 通信，IP 地址和 MAC 地址的变化情况是</p>
<p><img src="https://api2.mubu.com/v3/document_image/a11a5224-248d-4959-8fa9-703ceada63c9-12259280.jpg" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>源 IP 地址</th>
<th>目的 IP 地址</th>
<th>源 MAC 地址</th>
<th>目的 MAC 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>从 $H_1$ 到 $R_1$</td>
<td>$IP_1$</td>
<td>$IP_2$</td>
<td>$HA_1$</td>
<td>$HA_3$</td>
</tr>
<tr>
<td>从 $R_1$ 到 $R_2$</td>
<td>$IP_1$</td>
<td>$IP_2$</td>
<td>$HA_4$</td>
<td>$HA_5$</td>
</tr>
<tr>
<td>从 $R_2$ 到 $H_2$</td>
<td>$IP_1$</td>
<td>$IP_2$</td>
<td>$HA_6$</td>
<td>$HA_2$</td>
</tr>
</tbody>
</table>
</div>
<h6 id="APR 协议"><a href="#APR 协议" class="headerlink" title="APR 协议"></a>APR 协议</h6><p>　APR 协议又叫地址解析协议，该协议可以通过 IP 解析出对应的 MAC 地址。</p>
<p>　每台主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。<br>　当主机 A 要向本局域网上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 I 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。如果没有，ARP 进程就在本局域网上广播发送一个 ARP 请求分组（带上 A 和 B 的 IP 地址，以及 A 自己的 MAC 地址），其他主机收到广播包后，检查自己的 IP 地址跟 ARP 请求分组中的 IP 地址是否一致，如一致，单播发送 ARP 响应分组。如不一致，直接不理睬这个 ARP 请求分组。</p>
<p>　注意：１. 高速缓存中映射地址都有生存时间　2.ARP 解决的是 <strong> 同一个局域网 </strong> 上的主机或路由器的 IP 地址到 MAC 地址的映射问题。</p>
<h6 id="IP 数据报的格式"><a href="#IP 数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h6><p>　<img src="https://api2.mubu.com/v3/document_image/c7a76fbb-ff13-45ed-9d95-73613776ef79-12259280.jpg" alt="img"></p>
<p>(1)版本：占 4bit，目前主要是 $IPv_4$ 和 $IPv_6$</p>
<p>(2)首部长度：占 4bit，最大值是 15，该字段的单位是以 4B 为单位，所以 UP 首部最大长度是 15*4=60B</p>
<p>(3)总长度：数据报最大长度为 $2^{16}-1=65535B$</p>
<p>(4)标识：数据报超过网络的 MTU 而必须分片时，标识字段的值就会复制到所有数据报片的标识字段中，确保分片后的各个数据报片能正确地重装为原来的数据报</p>
<p>(5)标志：MF=1(more fragment)表示后面还有分片，MF=0 表示这个最后一个分片，DF(don’t fragment)=0 表示允许分片</p>
<p>(6)片偏移：分片后，某片在原分组中的相对位置</p>
<h6 id="内部网关协议：RIP 协议"><a href="# 内部网关协议：RIP 协议" class="headerlink" title="内部网关协议：RIP 协议"></a>内部网关协议：RIP 协议 </h6><p>　一种分布式的基于<strong> 距离向量 </strong> 的路由选择协议，其距离度量为跳数，每经过一个路由器跳数就加 1，最大跳数为 15，因此 RIP 只适用于小型互联网。</p>
<p>　特点：1. 仅和相邻路由器交换信息 2. 交换的信息是本路由器所知道的全部信息，即自己的路由表 3. 固定时间间隔交换路由信息</p>
<h6 id="内部网关协议：OSPF 协议"><a href="# 内部网关协议：OSPF 协议" class="headerlink" title="内部网关协议：OSPF 协议"></a>内部网关协议：OSPF 协议</h6><p>　全称叫开放最短路径优先(迪杰斯特拉算法)，特点：1. 使用洪泛法向本自治系统中所有路由器发送信息 2. 发送的信息是本路由器相邻的所有路由器的链路状态，所谓链路状态是指本路由器与哪些路由器相邻，以及该链路的”度量“ 3. 只有链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。</p>
<p>　路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库，这个数据库实际上就是全网的拓扑结构图，每一个路由器都知道全网有多少个路由器以及哪些路由器是相连的，度量是多少。而 RIP 协议的每一个路由器只知道到所有网络的距离以及下一跳路由器，而不知道全网的拓扑结构。</p>
<h6 id="外部网关协议：BGP（边界网关协议）"><a href="# 外部网关协议：BGP（边界网关协议）" class="headerlink" title="外部网关协议：BGP（边界网关协议）"></a>外部网关协议：BGP（边界网关协议）</h6><p>　边界网关协议力求寻找一条能够到达目的地网络且比较好的路由，并非寻找一条最佳路由。也就是可达性＞高效性</p>
<h6 id="内部网关协议和外部网关协议的区别？"><a href="# 内部网关协议和外部网关协议的区别？" class="headerlink" title="内部网关协议和外部网关协议的区别？"></a>内部网关协议和外部网关协议的区别？</h6><p>　想象成快递公司，外部网关协议就是不同省公司，不同省公司之间注重的是可达性。内部网关协议就是省公司内部，需要一套高效的快递派件规则，注重高效性。</p>
<h5 id="运输层"><a href="# 运输层" class="headerlink" title="运输层"></a>运输层</h5><p>　从 IP 层来说，通信的两端是两台主机。但严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。</p>
<p>　端口号：熟知端口号 0-1023，常用的端口号有</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>应用程序</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>FTP</td>
<td>21</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>DNS</td>
<td>53</td>
</tr>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
</tbody>
</table>
</div>
<h6 id="UDP 首部格式"><a href="#UDP 首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h6><p>　8 个字节，源端口、目的端口、长度、校验和</p>
<p><img src="https://api2.mubu.com/v3/document_image/b39fb60b-2654-458b-9e92-c9ac62c2c0a4-12259280.jpg" alt="img"></p>
<h6 id="TCP 首部格式"><a href="#TCP 首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h6><p><img src="https://api2.mubu.com/v3/document_image/17f72b14-01f3-4c0b-b39d-face6bb8cb40-12259280.jpg" alt="img"></p>
<p>　源端口和目的端口：占 2B</p>
<p>　序号：占 4B，指整个传送的数据的第一个字节的序号。范围是 $[0,2^{32}-1]$, 序号增加到 $2^{32}-1$ 后，下一个序号就又回到了 0。</p>
<p>　确认号：占 4B，是期望收到对方下一个报文段的第一个数据字节的序号。</p>
<p>　确认 ACK：仅 ACK=1 时确认号字段才有效，TCP 规定，在连接建立后所有传送的报文段都要把 ACK 置１</p>
<p>　同步 SYN：在连接建立时用来同步序号</p>
<h6 id="TCP 可靠传输的原因"><a href="#TCP 可靠传输的原因" class="headerlink" title="TCP 可靠传输的原因"></a>TCP 可靠传输的原因</h6><p>　差错控制：为每个报文段编号，并且有检错和重传机制</p>
<p>　流量控制：控制发送端发送报文段的速度，使接收端来得及接收，是一个端到端的过程。</p>
<p>　拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，是一个全局性的过程。</p>
<h6 id="拥塞控制方法"><a href="# 拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h6><p>　慢开始：指数增加报文段发送数量</p>
<p>　拥塞避免：线性增加报文段发送数量</p>
<p>　快重传：发送方只要收到连续３个重复确认，就应该立即进行重传，而不是等待超时重传。</p>
<p>　快恢复：新的发送方门限值 ssthresh＝cwnd/2，而不是从 1 开始</p>
<p><img src="https://api2.mubu.com/v3/document_image/110bf20e-0d42-4347-91a4-e5571295c01a-12259280.jpg" alt="img"></p>
<h5 id="网络安全"><a href="# 网络安全" class="headerlink" title="网络安全"></a>网络安全 </h5><h6 id="对称加密"><a href="# 对称加密" class="headerlink" title="对称加密"></a> 对称加密</h6><p>　加密密钥和解密密钥使用相同的密码体制，如 DES。问题在于密钥分配：使用密钥分配中心 KDC 会使得网络成本增加，不使用 KDC 的话会有密钥被劫持的风险。</p>
<h6 id="非对称加密"><a href="# 非对称加密" class="headerlink" title="非对称加密"></a>非对称加密 </h6><p>　公钥 $PK$ 公开，私钥 $SK$ 保密，如 $RSA$，发送者 A 用 B 的公钥 $PK_B$ 通过 $E$ 运算对明文 X 加密，得出密文 $Y$，发送给 B，B 用自己是私钥 $SK_B$ 通过 $D$ 运算进行解密，恢复出明文。<strong> 非对称加密算法的开销较大</strong>，在可见的将来还不会放弃传统加密算法。</p>
<p> <center>加密 　$Y=E_{PK_B}(X)$</center>　</p>
<p><center>　解密 　$D_{SK_B}=D_{SK_B}(E_{PK_B}(X))$</center>　</p>
<h5 id="计算机是怎么连上局域网的？"><a href="# 计算机是怎么连上局域网的？" class="headerlink" title="计算机是怎么连上局域网的？"></a>计算机是怎么连上局域网的？</h5><p>　计算机与外界局域网的连接是通过通信适配器 (网卡) 进行的。在这种通信适配器上面装有处理器和存储器（包括 RAM 和 ROM)。<strong>适配器和局域网之间的通信是通过电缆或双绞线以串行传输方式进行的，而适配器和计算机之间的通信则是通过计算机主板上的 IO 总线以并行传输方式进行 </strong>。因此，适配器的<strong> 一个重要功能就是要进行数据串行传输和并行传输的转换 </strong>。由于网络上的数据率和计算机总线上的数据率并不相同，因此在适配器中必须<strong> 装有对数据进行缓存的存储芯片 </strong>。在主板上插入适配器时，还必须把管理该适配器的设备驱动程序安装在计算机的操作系统中。这个驱动程序以后就会告诉适配器，应当<strong> 从存储器的什么位置上把多长的数据块发送到局域网，或者应当在存储器的什么位置上把局域网传送过来的数据块存储下来</strong>。适配器还要能够实现以太网协议</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>图解网络读书笔记</title>
    <url>/2021/11/17/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h5 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h5><h6 id="常见字段"><a href="# 常见字段" class="headerlink" title="常见字段"></a>常见字段</h6><p>　host：客户端发送请求时，⽤来指定服务器的域名。</p>
<p>　Content-Length：服务器在返回数据时，该字段表明本次回应的数据长度</p>
<p>　Connection：最常⽤于客户端要求服务器使⽤ TCP 持久连接，</p>
<p>　Content-Type：⽤于服务器回应时，告诉客户端，本次数据是什么格式，如 text/html; charset=utf-8</p>
<p>　Content-Encoding：数据的压缩⽅法。表示服务器返回的数据使⽤了什么压缩格式，如 gzip</p>
<span id="more"></span>
<h6 id="get 和 post 的区别"><a href="#get 和 post 的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别 </h6><p>　get 方法是请求从服务器获取资源，是<strong> 安全且幂等 </strong> 的，post 向 URI 指定的资源提交数据，数据就放在报文的 body 里，会修改服务器上的资源，所以是 <strong> 不安全 </strong> 的，且多次提交数据就会创建多个资源，所以 <strong> 不是幂等 </strong> 的</p>
<h6 id="双刃剑"><a href="# 双刃剑" class="headerlink" title="双刃剑"></a>双刃剑</h6><p>　HTTP 协议有优缺点⼀体的双刃剑，优点是无状态、明文传输，缺点是不安全</p>
<p>　无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以 <strong> 不需要额外的资源来记录状态信息，这能减轻服务器的负担</strong>，能够把更多的 CPU 和内存用来对外提供服务</p>
<p>　无状态的坏处，服务器没有记忆能力，它在完成有关联性的操作时会⾮常麻烦。例如登录 -&gt; 添加购物⻋-&gt; 下单 -&gt; 结算 -&gt;⽀付，这系列操作都要知道⽤户身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息</p>
<p>　明文传输：通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试⼯作带了极大的便利，缺点是不安全</p>
<p>　不安全：1. 明文 (不加密) 可能会被窃听 2. 不验证通信方的身份，因此有可能遭遇伪装 3. 无法证明报文的完整性，报文有可能已遭篡改</p>
<h6 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h6><p>　长连接：HTTP1.0 没发起一个请求就要重新建立一次 TCP 连接，所以通信开销较大。HTTP1.1 提出了长连接的通信方式，减轻了服务端的压力</p>
<p>　管道网络传输：在同⼀个 TCP 连接中，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间</p>
<p>　队头阻塞问题：顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后面排队的所有请求也⼀同被阻塞了，会导致客户端⼀直请求不到数据</p>
<h6 id="HTTPS 和 HTTP 的区别"><a href="#HTTPS 和 HTTP 的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h6><p>　1.HTTP 信息是明⽂传输，存在安全问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报文能够加密传输。</p>
<p>　2. HTTP 连接建立相对简单， TCP 三次握手之后便可进⾏ HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还要进行 SSL/TLS 的握⼿过程，才可以进入加密报⽂传输阶段。</p>
<p>　3.HTTP 端口号是 80，HTTPS 端口号是 443</p>
<p>　4.HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</p>
<h6 id="对称加密"><a href="# 对称加密" class="headerlink" title="对称加密"></a>对称加密 </h6><p>　加密密钥和解密密钥使用相同的密码体制，如 DES。问题在于密钥分配：使用密钥分配中心 KDC 会使得网络成本增加，不使用 KDC 的话会有<strong> 密钥被劫持的风险</strong>。</p>
<p><center>加密 　$Y=E_{PK_B}(X)$</center>　</p>
<h6 id="非对称加密"><a href="# 非对称加密" class="headerlink" title="非对称加密"></a>非对称加密 </h6><p>　公钥 $PK$ 公开，私钥 $SK$ 保密，如 $RSA$，发送者 A 用 B 的公钥 $PK_B$ 通过 $E$ 运算对明文 X 加密，得出密文 $Y$，发送给 B，B 用自己是私钥 $SK_B$ 通过 $D$ 运算进行解密，恢复出明文。<strong> 非对称加密算法的开销较大 </strong>，在可见的将来还不会放弃传统加密算法，<strong> 解决了密钥交换问题但速度慢</strong></p>
<p><center>　解密 　$D_{SK_B}=D_{SK_B}(E_{PK_B}(X))$</center>　</p>
<h6 id="HTTPS- 解决了哪些风险？"><a href="#HTTPS- 解决了哪些风险？" class="headerlink" title="HTTPS 解决了哪些风险？"></a>HTTPS 解决了哪些风险？</h6><p>　混合加密实现信息的机密性，解决了窃听的风险。摘要算法来实现完整性，解决了篡改的风险。 将服务器公钥放入到数字证书中，解决了冒充的风险</p>
<p>　混合加密：先使用 <strong> 对称加密算法对数据 </strong> 进行加密，然后使用非对称加密算法对 <strong> 对称加密的密钥 </strong> 进行非对称加密，之后再把加密后的密钥和加密后的数据发送给接收方</p>
<p>HTTPS 是如何建立连接的？</p>
<p>　SSL/TLS 的「握⼿阶段」涉及四次通信</p>
<ul>
<li>1. 由客户端向服务器发起 <strong> 加密通信请求</strong>，也就是 ClientHello 请求<ul>
<li>客户端⽀持的 SSL/TLS 协议版本，如 TLS 1.2 版本</li>
<li>客户端生成的随机数（ Client Random ），后面用于 <strong> 生成会话秘钥</strong></li>
<li>客户端⽀持的密码套件列表，如 RSA 加密算法</li>
</ul>
</li>
<li>2. 服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello<ul>
<li>确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。 </li>
<li>服务器⽣产的随机数（ Server Random ），后面用于生成 <strong> 会话秘钥</strong></li>
<li>确认的密码套件列表，如 RSA 加密算法</li>
<li>服务器的数字证书</li>
</ul>
</li>
<li>3. 客户端通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送如下信息<ul>
<li>⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密</li>
<li>加密通信算法改变通知，表示随后的信息都将用 <strong> 会话秘钥 </strong> 加密通信</li>
<li>服务器握⼿结束通知，表示服务器的握手阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验</li>
</ul>
</li>
<li>4. 服务器的最后回应，服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的 <strong> 会话秘钥</strong><ul>
<li>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。 </li>
<li>服务器握⼿结束通知，表示服务器的握手阶段已经结束。这⼀项同时把之前所有内容的发⽣的数据做个摘要，⽤来供客户端校验</li>
</ul>
</li>
</ul>
<h6 id="HTTP-1-1、HTTP-2、HTTP-3- 演变"><a href="#HTTP-1-1、HTTP-2、HTTP-3- 演变" class="headerlink" title="HTTP/1.1、HTTP/2、HTTP/3 演变"></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h6><p>　HTTP/1.1 相比 HTTP/1.0：TCP 长连接、管道网络传输，即只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间</p>
<p>　HTTP/1.1 的缺陷</p>
<ul>
<li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是 <strong> 队头阻塞</strong></li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务器只能被动响应。</li>
</ul>
<p>　HTTP2 优化</p>
<p>　头部压缩：同时发出多个请求，它们的头部是⼀样的或是相似的，此时协议会帮你消除重复的部分，这就是所谓的 HPACK 算法，在 <strong> 客户端和服务器同时维护⼀张头信息表 </strong>，所有字段都会存⼊这个表，⽣成⼀个索引号，<strong> 以后就不发送同样字段了，</strong>只发送索引号，这样就提⾼速度了。</p>
<p>　二进制格式：HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，⽽是全面采用了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）：头信息帧和数据帧</p>
<p><img src="https://api2.mubu.com/v3/document_image/eec7b738-6ed1-4d2f-b462-91a09602b6ca-12259280.jpg" alt="img"></p>
<p>　这样虽然对人不友好，但是对计算机友好，收到报⽂后，无需再将明文的报文转成⼆进制，而是直接解析⼆进制报文，这增加了数据传输的效率。</p>
<p>　多路复用：HTTP/2 可以在⼀个连接中并发多个请求或回应，⽽不用按照顺序⼀⼀对应。 移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，提高了连接的利用率。</p>
<p>　 举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就 回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>
<p>　HTTP2 缺陷：多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 QUIC，UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传问题，基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输</p>
<h6 id="HTTP-1-1 优化"><a href="#HTTP-1-1 优化" class="headerlink" title="HTTP/1.1 优化"></a>HTTP/1.1 优化</h6><p>​    1. 短连接改成长连接</p>
<p>　2. 尽量避免发送 HTTP 请求：对于⼀些具有重复性的 HTTP 请求，如每次请求得到的数据都⼀样的，我们可以把这对 <strong> 请求 - 响应 </strong> 的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了</p>
<p>　3. 减少重定向请求次数：服务器上的⼀个资源可能由于迁移、维护等原因从 url1 移⾄ url2 后，⽽客户端不知情，它还是继续请求 url1，这 时服务器不能粗暴地返回错误，⽽是通过 302 响应码和 Location 头部，告诉客户端该资源已经迁移到 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。解决方法：<font color="red">重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了</font></p>
<p><img src="https://api2.mubu.com/v3/document_image/aff7a832-be69-458a-832e-3b0f7134d052-12259280.jpg" alt="img"></p>
<p>　4. 延迟发送请求：⼀般 HTML ⾥会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来， 于是可以通过 <strong> 按需获取 </strong> 的⽅式，来减少第⼀时间的 HTTP 请求次数。请求网页的时候，没必要把全部资源都获取到，只获取当前用户所看到的页面资源，当⽤户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果</p>
<p>　5. 使用合适的压缩算法来降低传输资源的大小</p>
<h5 id="TCP 协议"><a href="#TCP 协议" class="headerlink" title="TCP 协议"></a>TCP 协议 </h5><h6 id="TCP 最大连接数是多少？"><a href="#TCP 最大连接数是多少？" class="headerlink" title="TCP 最大连接数是多少？"></a>　TCP 最大连接数是多少？</h6><p>　　理论上，服务端最大并发 TCP 连接数是客户端 IP 数×客户端端口数，即 $2^{32}<em>2^{16}=2^{48}$, 但实际上连接数不能达到理论上限。一是因为<strong> 文件描述符限制</strong>，Socket 都是文件，所以首先要通过 ulimit 配置文件描述符的数⽬，二是<em>* 内存限制</em></em>，每个 TCP 连接都要占用内存</p>
<h6 id="TCP 为什么需要三次握手？"><a href="#TCP 为什么需要三次握手？" class="headerlink" title="TCP 为什么需要三次握手？"></a>　TCP 为什么需要三次握手？</h6><p><img src="https://api2.mubu.com/v3/document_image/84630bb9-1d87-4840-a437-c73d05351558-12259280.jpg" alt="img"></p>
<p>　1. 阻止重复历史连接的初始化（主要原因）　2. 同步双方的初始序列号　3. 避免资源浪费</p>
<p>　1)⼀个旧 SYN 报文比最新的 SYN  报文早到达了服务端； 那么此时服务端就会回⼀个 SYN + ACK 报⽂给客户端； 客户端收到后可以根据自身的上下文，判断这是⼀个历史连接（序列号过期或超时），那么客户端就会发送 RST 报文给服务端，表示中止这⼀次连接</p>
<p><img src="https://api2.mubu.com/v3/document_image/430ff806-e420-4450-ba9f-f15b07146f92-12259280.jpg" alt="img"></p>
<p> 如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端准备发送第三次报文时，客户端因有足够的上下⽂来判断当前连接是否是历史连接：</p>
<ul>
<li>如果是历史连接（序列号过期或超时），则第三次握⼿发送的报⽂是 <strong>RST</strong> 报文，以此中止历史连接；</li>
<li>如果不是历史连接，则第三次发送的报⽂是 <strong>ACK</strong> 报文，通信双⽅就会成功建立连接；</li>
</ul>
<p>2）两次握手只保证了⼀方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收</p>
<p>3）如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效连接，造成不必要的资源浪费</p>
<h6 id="为什么 -TIME-WAIT- 等待的时间是 -2MSL？"><a href="# 为什么 -TIME-WAIT- 等待的时间是 -2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 TIME_WAIT 等待的时间是 2MSL？</h6><p>　当 TCP 执行一个主动关闭，并发回最后一个 ACK，该连接必须在 TIME_WAIT 状态停留的时间为 2 倍的 MSL。这样可让 TCP 再次发送最后的 ACK 以防这个 ACK 丢失</p>
<h6 id="为什么需要 -TIME-WAIT- 状态？"><a href="# 为什么需要 -TIME-WAIT- 状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 TIME_WAIT 状态？</h6><p>　主动发起关闭连接的⼀方，才会有 TIME-WAIT 状态</p>
<p>　1. 防止收到旧连接的数据包，图中黄色框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被网络延迟了。 这时有相同端⼝的 TCP 连接被复用后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产⽣数据错乱等严重的问题。<strong>经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/c9081c93-93db-429f-94a1-03dd0546db8d-12259280.jpg" alt="img"></p>
<p>　2. 保证连接正确关闭，如果第四次挥手的 ACK 报文在网络中丢失了，没有 TIME_WAIT 状态而是直接进入 CLOSED 状态的话，那么服务端一直处于 LAST_ACK 状态，导致连接不能正常关闭</p>
<h6 id="TIME-WAIT- 过多有什么危害？"><a href="#TIME-WAIT- 过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h6><p>　如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求</p>
<p>　危害：1. 内存资源占用　2. 端口资源的占用</p>
<p>　如果客户端的 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接</p>
<p>　解决：修改内核参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> 表示开启重用。允许将 TIME-WAIT sockets 重新用于新的 TCP 连接，默认为<span class="number">0</span>，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span> 表示开启 TCP 连接中 TIME-WAIT sockets 的快速回收，默认为<span class="number">0</span>，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure>
<h6 id="半连接队列和全连接队列？"><a href="# 半连接队列和全连接队列？" class="headerlink" title="半连接队列和全连接队列？"></a>半连接队列和全连接队列？</h6><p>　在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是半连接队列 (SYN 队列) 和全连接队列（accept 队列）。</p>
<p>　服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来</p>
<p>　当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发⽣ TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。</p>
<p>　增大 TCP 半连接队列的方式是增大 /proc/sys/net/ipv4/tcp_max_syn_backlog</p>
<p>　增大 TCP 全连接队列的方式是增大 listen() 函数中的 backlog</p>
<h5 id="键入网址到网页显示，期间发生了什么？"><a href="# 键入网址到网页显示，期间发生了什么？" class="headerlink" title="键入网址到网页显示，期间发生了什么？"></a>键入网址到网页显示，期间发生了什么？</h5><p>1. 解析 URL，确定 Web 服务器和文件名，根据这些信息来生成 HTTP 请求消息</p>
<p>2. 应用层：查询服务器域名对应的 IP 地址，此步骤需要 DNS 域名解析。</p>
<p>3. 运输层：HTTP 是基于 TCP 的，已知 IP 地址后就可以建立 TCP 连接（三次握手），建立连接后，TCP 报⽂中的数据部分就是存放 HTTP 头部 + 数据</p>
<p>4. 网络层：IP 协议封装源 IP 地址和目的 IP 地址，通过路由器进行路由，生成了 IP 头部之后，接下来⽹络包还需要在 IP 头部的前面加上 MAC 头部</p>
<p>5. 链路层：根据 MAC 地址进行寻址，网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和起始帧分界符， 在末尾加上用于检测错误的帧校验序列</p>
<p><img src="https://api2.mubu.com/v3/document_image/5c909a03-fb39-4f2a-9eb8-7305ce5b2557-12259280.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>List</title>
    <url>/2021/12/25/List/List/</url>
    <content><![CDATA[<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>　ArrayList 底层是动态数组，是一个 <strong> 线性以存储数据为目的数据结构</strong>。主要特点</p>
<ul>
<li><p>具有索引，能够通过索引对 ArrayList 对象进行访问, 时间复杂度为 O(1)</p>
</li>
<li><p>一个 Array 对象里面只能存储一种数据类型, 比如全部存储 int 类型</p>
</li>
<li><p><strong>能够动态地进行扩容和缩容</strong></p>
<span id="more"></span>
<p><img src="https://api2.mubu.com/v3/document_image/e7007774-c330-4a2f-b220-03b5994983eb-12259280.jpg" alt="img"></p>
</li>
</ul>
<p>如图，ArrayList 类中应该有 3 个比较重要的属性</p>
<ul>
<li>data：存放数据</li>
<li>size：指向 data 中下一个可以存放数据的索引, 初始值为 0</li>
<li>capatity：表示 ArrayList 的容量，可以动态改变</li>
</ul>
<h5 id="构造方法"><a href="# 构造方法" class="headerlink" title="构造方法"></a>构造方法 </h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> E[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造，默认容量为 10，this() 表示访问本类的构造方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有参构造</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 初始容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = (E[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="一些常用方法"><a href="# 一些常用方法" class="headerlink" title="一些常用方法"></a>一些常用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回有效元素个数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 获取容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> data.length;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 判断 ArrayList 是否为空</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 传入的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 索引为 index 的元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 边界条件</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Required index&gt;=0 and index &lt;=arr.size&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> data[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回最后一个元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> get(size - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回第一个元素</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> index 替换位置的索引</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e 替换后的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Required index&gt;=0 and index &lt;=arr.size&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       data[index] = e;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e 某个元素 e</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 查询 ArrayList 中是否包含 e</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e 查找的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 元素的索引，若不存在该元素，返回 -1</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (data[i].equals(e)) &#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="扩容／缩容"><a href="# 扩容／缩容" class="headerlink" title="扩容／缩容"></a>扩容／缩容</h6><p>　当 Array 对象容量已满, 想要继续向 Array 对象增加元素需要扩容，当对象元素只占容量的很少一部分时, 为节省内存空间，需要缩容，扩容缩容的操作主要是构造一个新的数组, 将原数组内的元素全部复制到新数组里面，然后 data 指向新数组即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param newCapacity 扩容后的容量</span><br><span class="line"> */</span><br><span class="line">private void resize(int newCapacity) &#123;</span><br><span class="line">    // 新的容量</span><br><span class="line">    E[] newData = (E[]) new Object[newCapacity];</span><br><span class="line">    // 数组重新赋值</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        newData[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 成员变量 data 数组换成新的数组</span><br><span class="line">    data = newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="向指定位置插入一个新元素"><a href="# 向指定位置插入一个新元素" class="headerlink" title="向指定位置插入一个新元素"></a>向指定位置插入一个新元素</h6><p>　若 ArrayList 容量已满，需要对内置的数组进行扩容, 跟 ArrayList 一样，选择 1.5 倍扩容，注意，由于运算符优先级的原因，不能写成<code>int newCapacity = data.length + data.length &gt;&gt; 1</code>，比如这段代码，b 的输出为 10，而不是 15.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = a + a &gt;&gt; 1;</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e     添加的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Required index&gt;=0 and index &lt;=arr.size&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组已满，扩容</span></span><br><span class="line">        <span class="keyword">if</span> (size == data.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = data.length + (data.length &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">          注意 如果写成 int newCapacity = data.length + data.length &gt;&gt; 1;  也就是位运算不加括号   算出来结果还是 10</span></span><br><span class="line"><span class="comment">            int i = 10;</span></span><br><span class="line"><span class="comment">            System.out.println(i + i &gt;&gt; 1);    10</span></span><br><span class="line"><span class="comment">            System.out.println(i + (i &gt;&gt; 1));  15</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从尾部开始，将 index 之后的元素, 一个个向后移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">            data[i + <span class="number">1</span>] = data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入新元素</span></span><br><span class="line">        data[index] = e;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="在头 - 尾部插入元素"><a href="# 在头 - 尾部插入元素" class="headerlink" title="在头 / 尾部插入元素"></a>在头 / 尾部插入元素</h6><p>　　注意 size 的含义，size 表示下一个要存放的元素的索引，因此是　<code>add(size, e);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(<span class="number">0</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    add(size, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="移除指定位置的元素"><a href="# 移除指定位置的元素" class="headerlink" title="移除指定位置的元素"></a>移除指定位置的元素</h6><p>　为了防止反复添加 / 删除元素导致频繁进行 resize 操作（每次都要 new 一个新数组）带来的性能消耗，所以把删除元素后 resize 的条件设置得苛刻一些，宁愿浪费一些空间，也不要引起复杂度的震荡。这点跟 HashMap 链表转红黑树有点类似，转红黑树的条件是链表长度 &gt;=8，红黑树退化成链表的条件是 &lt;6，就是为了防止链表长度为 7 时，如果此时频繁添加元素后再删除，会导致数据结构在红黑树和链表之间的来回横跳而导致性能下降。</p>
<p>　当 ArrayList 有效元素数量小于容积的 1/4 时，我们只缩容 1/2，防止频繁扩容缩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Required index&gt;=0 and index &lt;=arr.size&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    E e = data[index];</span><br><span class="line">    <span class="comment">// 将 index 之后的元素, 一个个向前移 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        data[i - <span class="number">1</span>] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会导致数组越界   最后一次循环是 i = size - 1,data[size-1] = data[size]，实际上 data[size] 已经越界</span></span><br><span class="line">    <span class="comment">//        for (int i = index; i &lt; size; i++) &#123;</span></span><br><span class="line">    <span class="comment">//            data[i] = data[i + 1];</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新元素个数</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 删除元素后，原先的最后一个位置中的元素置为 null</span></span><br><span class="line">    data[size] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态减少空间</span></span><br><span class="line">    <span class="comment">// 当 Array 元素小于容积 1/4 时，我们只缩容 1/2, 防止频繁扩容缩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; data.length / <span class="number">4</span> &amp;&amp; data.length / <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        resize(data.length / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除元素"><a href="# 删除元素" class="headerlink" title="删除元素"></a>删除元素</h6><p>　注意 size 的含义，size 表示下一个要存放的元素的索引，因此有效元素的最后一个索引是　<code>size - 1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到元素</span></span><br><span class="line">    <span class="keyword">int</span> index = find(e);</span><br><span class="line">    <span class="comment">// index != -1 表示 List 中含有该元素</span></span><br><span class="line">    <span class="keyword">if</span> (index != -<span class="number">1</span>) &#123;</span><br><span class="line">        remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="打印 ArrayList 中的元素"><a href="# 打印 ArrayList 中的元素" class="headerlink" title="打印 ArrayList 中的元素"></a>打印 ArrayList 中的元素</h6><p>　重写 toString()，重写后直接打印就可以统计元素个数和容积。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    res.append(<span class="string">&quot;Array: size=&quot;</span> + size + <span class="string">&quot; capacity=&quot;</span> + data.length);</span><br><span class="line">    res.append(<span class="string">&quot; [&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res.append(data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != size - <span class="number">1</span>) &#123;</span><br><span class="line">            res.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试一下"><a href="# 测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            arr.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试扩容功能</span></span><br><span class="line">        arr.add(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试增加元素功能</span></span><br><span class="line">        arr.add(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        arr.addFirst(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试删除元素功能</span></span><br><span class="line">        arr.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        arr.removeElement(<span class="number">10</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试动态减小空间功能</span></span><br><span class="line">        arr.removeElement(<span class="number">9</span>);</span><br><span class="line">        arr.removeElement(<span class="number">8</span>);</span><br><span class="line">        arr.removeElement(<span class="number">7</span>);</span><br><span class="line">        arr.removeElement(<span class="number">6</span>);</span><br><span class="line">        arr.removeElement(<span class="number">5</span>);</span><br><span class="line">        arr.removeElement(<span class="number">4</span>);</span><br><span class="line">        arr.removeElement(<span class="number">1</span>);</span><br><span class="line">        arr.removeElement(<span class="number">2</span>);</span><br><span class="line">        arr.removeElement(<span class="number">3</span>);</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">        arr.removeLast();</span><br><span class="line">        System.out.println(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Array: size=<span class="number">10</span> capacity=<span class="number">10</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="comment">// 添加元素 0~9</span></span><br><span class="line">Array: size=<span class="number">11</span> capacity=<span class="number">15</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]  <span class="comment">// 添加了 10，同时扩容</span></span><br><span class="line">Array: size=<span class="number">12</span> capacity=<span class="number">15</span> [<span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>] <span class="comment">// 在位置 1 添加元素 100</span></span><br><span class="line">Array: size=<span class="number">13</span> capacity=<span class="number">15</span> [<span class="number">1000</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>] <span class="comment">// 在头部添加元素 1000</span></span><br><span class="line">Array: size=<span class="number">12</span> capacity=<span class="number">15</span> [<span class="number">1000</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">Array: size=<span class="number">11</span> capacity=<span class="number">15</span> [<span class="number">1000</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="comment">// 容量为 11</span></span><br><span class="line">Array: size=<span class="number">2</span> capacity=<span class="number">7</span> [<span class="number">1000</span>, <span class="number">0</span>] <span class="comment">// 测试缩容 有效元素个数只有容量的 1/4 时 容量变成原来的 1/2</span></span><br><span class="line">Array: size=<span class="number">1</span> capacity=<span class="number">7</span> [<span class="number">1000</span>]</span><br></pre></td></tr></table></figure>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>　LinkedList 底层是链表，增删快，查找慢。重要特性：</p>
<ul>
<li><p>链表可以动态地增加数据，而不需要提前知道数据量地多少</p>
</li>
<li><p>链表只能从头节点开始依次向后寻找，增加，删除，查找，修改均是如此。</p>
<p><img src="https://api2.mubu.com/v3/document_image/9d3f487b-997d-46bc-ac28-0707ac462374-12259280.jpg" alt="img"></p>
</li>
</ul>
<p>虚拟头节点通常是作为链表的入口。</p>
<h5 id="构造方法 -1"><a href="# 构造方法 -1" class="headerlink" title="构造方法"></a>构造方法</h5><p>　成员变量：主要是内部类 Node 结点（结点包含值和 next 指针），还有哨兵节点 dummyHead，size 表示非虚拟头节点的节点个数，初始值为 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 内部类，也就是 Node 结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 值和 next 指针</span></span><br><span class="line">        <span class="keyword">private</span> E e;</span><br><span class="line">        <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Node 结点的几个构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e, Node next)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.e = e;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(e, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node dummyHead;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时 size 为 0，虚拟节点的值和 next 指针都为 null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dummyHead = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常用方法"><a href="# 常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>　获取链表元素个数和判断链表是否为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="根据索引获取元素 - 获取第一个元素"><a href="# 根据索引获取元素 - 获取第一个元素" class="headerlink" title="根据索引获取元素 / 获取第一个元素"></a>根据索引获取元素 / 获取第一个元素</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据索引获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 索引越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed. Illegal index.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Node cur = dummyHead.next;</span><br><span class="line">        <span class="comment">// 走 index 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.e;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="查询是否包含某个节点"><a href="# 查询是否包含某个节点" class="headerlink" title="查询是否包含某个节点"></a>查询是否包含某个节点</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.e.equals(e))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在索引处赋新的值"><a href="# 在索引处赋新的值" class="headerlink" title="在索引处赋新的值"></a>在索引处赋新的值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed. Illegal index.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的值替换原来的值</span></span><br><span class="line">    cur.e = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在指定位置添加节点：需要找到待插入位置的前一个结点 prev</p>
<p><strong>使用虚拟头节点的好处是，即使在第一个位置插入新节点，整个过程也是一样的，无需特殊处理。</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/4cea9c32-ebdc-499b-9b53-d6a68e0b77d9-12259280.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">       <span class="comment">// 越界处理</span></span><br><span class="line">       <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed. Illegal index.&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 头节点</span></span><br><span class="line">       Node cur = dummyHead.next;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 找到 prev 结点 也就是 index 节点的前一个</span></span><br><span class="line">       Node prev = dummyHead;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">           prev = prev.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 新的结点</span></span><br><span class="line">       Node newNode = <span class="keyword">new</span> Node(e);</span><br><span class="line">       <span class="comment">// 步骤 1: 新结点指向 index 结点</span></span><br><span class="line">       newNode.next = prev.next;</span><br><span class="line">       <span class="comment">// 步骤 2: prev 结点指向新节点</span></span><br><span class="line">       prev.next = newNode;</span><br><span class="line">       <span class="comment">// 添加完后 size+1</span></span><br><span class="line">       size++;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">       add(<span class="number">0</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">       add(size, e);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除指定位置的节点"><a href="# 删除指定位置的节点" class="headerlink" title="删除指定位置的节点"></a>删除指定位置的节点 </h6><p> 需要一个 prev 和 cur 指针，找到 cur 节点后，prev 跳过 cur 节点，然后释放 cur 节点即可。</p>
<p><img src="https://api2.mubu.com/v3/document_image/2d887628-6062-4eb7-89a4-5af386ca2db6-12259280.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 越界</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Get failed. Illegal index.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到待删除节点的前一个节点</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cur 是待删除节点</span></span><br><span class="line">    Node cur = prev.next;</span><br><span class="line">    <span class="comment">// prev 指向待删除节点的后一个节点</span></span><br><span class="line">    prev.next = cur.next;</span><br><span class="line">    E res = cur.e;</span><br><span class="line">    <span class="comment">// 释放待删除节点</span></span><br><span class="line">    cur = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 元素数量 -1</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 返回删除的节点的值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除含有某一个值的节点"><a href="# 删除含有某一个值的节点" class="headerlink" title="删除含有某一个值的节点"></a>删除含有某一个值的节点</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针的思想</span></span><br><span class="line">    Node prev = dummyHead;</span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    Node delNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 找到了就释放节点，然后 break 跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur.e.equals(e))&#123;</span><br><span class="line">            delNode = cur;</span><br><span class="line">            prev.next = delNode.next;</span><br><span class="line">            cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没找到  快慢指针一起往后遍历</span></span><br><span class="line">            prev = prev.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在该节点，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (delNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Doesn&#x27;t contain e !!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="删除链表头节点 -removeFirst- 和 - 删除链表尾节点 -removeLast"><a href="# 删除链表头节点 -removeFirst- 和 - 删除链表尾节点 -removeLast" class="headerlink" title="删除链表头节点 removeFirst() 和 删除链表尾节点 removeLast()"></a>删除链表头节点 removeFirst() 和 删除链表尾节点 removeLast()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remove(size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印方法"><a href="# 打印方法" class="headerlink" title="打印方法"></a>打印方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Node cur = dummyHead.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sb.append(cur + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试"><a href="# 测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            linkedList.addFirst(i);</span><br><span class="line">            System.out.println(linkedList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">666</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">        linkedList.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        linkedList.removeElement(<span class="number">0</span>);</span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line"></span><br><span class="line">        linkedList.removeElement(<span class="number">888</span>);<span class="comment">// 抛出异常, 因为不存在这个元素</span></span><br><span class="line">        System.out.println(linkedList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">666</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span>-&gt;<span class="keyword">null</span></span><br><span class="line"><span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="keyword">null</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException</span><br><span class="line">	at LinkedList$Node.access$<span class="number">100</span>(LinkedList.java:<span class="number">3</span>)</span><br><span class="line">	at LinkedList.removeElement(LinkedList.java:<span class="number">151</span>)</span><br><span class="line">	at LinkedListTest.main(LinkedListTest.java:<span class="number">21</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/2021/12/26/Stack/Stack/</url>
    <content><![CDATA[<p>栈也是一种线性的，用于存储数据的线性数据结构。栈主要支持三种操作</p>
<p>1. 入栈(push)    2. 出栈(pop)   3. 取栈顶元素(peek)</p>
<p>栈的主要特点是 <strong> 先进后出</strong>。</p>
<span id="more"></span>
<p><img src="https://api2.mubu.com/v3/document_image/2a47198f-359f-4282-999a-01b54d5e22b6-12259280.jpg" alt="img"></p>
<p>栈的内部也有一个 size 指针, 指向 <strong> 下一个入栈的元素位置</strong>。push 操作以后, size 指针上移，pop 操作以后, size 指针下移。</p>
<h4 id="栈的实现"><a href="# 栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>　栈主要有两种实现方式：数组／链表，为了增强复用性，我们不从头实现一个栈。而是定义一个栈的接口, 去实现这个接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ArrayStack- 数组栈"><a href="#ArrayStack- 数组栈" class="headerlink" title="ArrayStack 数组栈"></a>ArrayStack 数组栈 </h5><p> 定义一个 ArrayStack 类去实现 Stack 接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量是之前的动态数组</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.array = <span class="keyword">new</span> ArrayList&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// push 后 size+1</span></span><br><span class="line">        array.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (array.getSize() == <span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> array.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.getCapacity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.getSize(); i++) &#123;</span><br><span class="line">            sb.append(array.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != array.getSize() - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;] top&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试一下"><a href="# 测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.peek();</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈中元素个数: &quot;</span> + stack.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈容量: &quot;</span> + stack.getCapacity());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈顶元素: &quot;</span> + stack.peek());</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">栈中元素个数: <span class="number">1</span></span><br><span class="line">栈容量: <span class="number">5</span></span><br><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">栈顶元素: <span class="number">0</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Stack is empty</span><br><span class="line">	at ArrayStack.pop(ArrayStack.java:<span class="number">34</span>)</span><br><span class="line">	at ArrayStackTest.main(ArrayStackTest.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<h5 id="LinkedList-Stack- 链表栈"><a href="#LinkedList-Stack- 链表栈" class="headerlink" title="LinkedList Stack 链表栈"></a>LinkedList Stack 链表栈 </h5><p> 定义一个 LinkedListStack 类去实现 Stack 接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        list.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.getSize() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Stack is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Stack: &quot;</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.getSize(); i++) &#123;</span><br><span class="line">            sb.append(list.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != list.getSize() - <span class="number">1</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;] top&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试一下 -1"><a href="# 测试一下 -1" class="headerlink" title="测试一下"></a>测试一下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListStackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedListStack&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedListStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈中元素个数: &quot;</span> + stack.getSize());</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈容量: &quot;</span> + stack.getCapacity());</span><br><span class="line">        System.out.println(stack);</span><br><span class="line">        System.out.println(<span class="string">&quot; 栈顶元素: &quot;</span> + stack.peek());</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] top</span><br><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">栈中元素个数: <span class="number">1</span></span><br><span class="line">栈容量: <span class="number">1</span></span><br><span class="line">Stack: [<span class="number">0</span>] top</span><br><span class="line">栈顶元素: <span class="number">0</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalArgumentException: Stack is empty</span><br><span class="line">	at LinkedListStack.pop(LinkedListStack.java:<span class="number">26</span>)</span><br><span class="line">	at LinkedListStackTest.main(LinkedListStackTest.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure>
<h5 id="数组栈和链表栈性能对比"><a href="# 数组栈和链表栈性能对比" class="headerlink" title="数组栈和链表栈性能对比"></a>数组栈和链表栈性能对比</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">timeCost</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="keyword">int</span> opCount)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; opCount; i++) &#123;</span><br><span class="line">            stack.push(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> (end - start) / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack&lt;Integer&gt; stack1 = <span class="keyword">new</span> ArrayStack&lt;&gt;();</span><br><span class="line">        LinkedListStack&lt;Integer&gt; stack2 = <span class="keyword">new</span> LinkedListStack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> opCount = <span class="number">10000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;StackArray 花费时间:&quot;</span>+timeCost(stack1,opCount)+<span class="string">&quot; s.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedListStack 花费时间:&quot;</span>+timeCost(stack2,opCount)+<span class="string">&quot; s.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">opCount = <span class="number">1000</span></span><br><span class="line">StackArray 花费时间:<span class="number">0.001</span> s.</span><br><span class="line">LinkedListStack 花费时间:<span class="number">0.006</span> s.</span><br><span class="line"></span><br><span class="line">opCount = <span class="number">10000</span></span><br><span class="line">StackArray 花费时间:<span class="number">0.003</span> s.</span><br><span class="line">LinkedListStack 花费时间:<span class="number">0.207</span> s.</span><br><span class="line"></span><br><span class="line">opCount = <span class="number">100000</span></span><br><span class="line">StackArray 花费时间:<span class="number">0.01</span> s.</span><br><span class="line">LinkedListStack 花费时间:<span class="number">20.659</span> s.</span><br></pre></td></tr></table></figure>
<p>结论：加大了数据规模以后, 链表栈耗费时间较多</p>
<p>数组栈的开销主要是 resize 操作. 随着数据规模的增大, resize 的频率在不断降低, 因为我们实现的 Array 进行 resize 时一次就扩大为原来的 1.5 倍, 存储空间指数级上升. 换句话说, 随着数据规模的增大, resize 操作的均摊开销将会越来越小.<br>链表栈的开销主要是每一次增加节点都需要 new 一个新的对象. 随着数据规模的增大, 操作系统寻找一片新的空间将会越来越困难, 开销将变得越来越大.</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue</title>
    <url>/2021/12/26/Queue/Queue/</url>
    <content><![CDATA[<p> 队列是一种线性的，用于存储数据的线性数据结构。主要特点是先进先出，队列主要支持两种操作：</p>
<ol>
<li><p> 入队 (offer)    2. 出队 (poll)   3. 取队首元素 (peek)</p>
<span id="more"></span>
</li>
</ol>
<p> 队列的内部也有一个指针, 指向下一个入队元素的索引。</p>
<p> 队列的实现主要有两种方式：数组 / 链表，为了增强代码的复用性和解耦，我们不从头实现一个队列。而是定义一个队列的接口，去实现这个接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 定义一个 ArrayQueue 类实现 Queue 接口即可，这里使用数组的方式实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量 动态数组 </span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line">    <span class="comment">// 构造方法  初始化动态数组 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        arrayList.addLast(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Queue is empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.getFirst();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">&quot;Queue: front [&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.getSize(); i++) &#123;</span><br><span class="line">            sb.append(arrayList.get(i));</span><br><span class="line">            <span class="keyword">if</span> (i != arrayList.getSize() - <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;] tail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue: front [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] tail</span><br><span class="line"> 队列元素个数为:<span class="number">5</span></span><br><span class="line">Queue: front [<span class="number">3</span>, <span class="number">4</span>] tail</span><br><span class="line"> 队首元素:<span class="number">3</span></span><br><span class="line"> 队列元素个数为:<span class="number">2</span></span><br><span class="line">Queue: front [] tail</span><br><span class="line"> 队列元素个数为:<span class="number">0</span></span><br><span class="line"><span class="keyword">null</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>AVL 树</title>
    <url>/2021/12/28/AVL%E6%A0%91/AVL%E6%A0%91/</url>
    <content><![CDATA[<p>　<strong>AVL 树 </strong> 是最先发明的自平衡二叉查找树。在 AVL 树中 <strong> 任何节点的两个子树的高度最大差别为 1</strong>，所以它也被称为 <strong> 高度平衡树</strong>，由 G. M. Adelson-Velsky 和 E. M. Landis 发明，因此叫 Adelson-Velsky-Landis Tree（AVL）, 可以看出，所有节点左右子树的高度差最大为 1，这样的二分搜索树就是 AVL 树</p>
<p><img src="https://api2.mubu.com/v3/document_image/ded5422a-9f37-4ab0-8d70-271f7f8fc3d3-12259280.jpg" alt="img"></p>
<h4 id="AVL 实现"><a href="#AVL 实现" class="headerlink" title="AVL 实现"></a>AVL 实现 </h4><h5 id="构造方法"><a href="# 构造方法" class="headerlink" title="构造方法"></a> 构造方法</h5><p>　构造方法跟 BST 类似，区别在于多了一个成员变量 height，用于记录节点的高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> K key;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node left, right;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> height;<span class="comment">// 以当前 node 为根的树的高度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 高度初始化为 1</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">            height = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取节点高度 getHeight-Node-node- 与 - 获取平衡因子 private-int-getBalanceFactor-Node-node"><a href="# 获取节点高度 getHeight-Node-node- 与 - 获取平衡因子 private-int-getBalanceFactor-Node-node" class="headerlink" title="获取节点高度 getHeight(Node node) 与 获取平衡因子 private int getBalanceFactor(Node node)"></a>获取节点高度 getHeight(Node node) 与 获取平衡因子 private int getBalanceFactor(Node node)</h5><p>平衡因子的定义是左子树高度 - 右子树高度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取以 node 为根的树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getHeight(node.left) - getHeight(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="以下方法和 BST 完全一样："><a href="# 以下方法和 BST 完全一样：" class="headerlink" title="以下方法和 BST 完全一样："></a>以下方法和 BST 完全一样：</h5><ul>
<li>int getSize()</li>
<li>bool isEmpty()</li>
<li>bool contains (K key)</li>
<li>V get (K key)</li>
<li>Node getNode(Node node,  K key)</li>
<li>void set (K key, V newNode)</li>
<li>minimum(Node node)</li>
</ul>
<h4 id="AVL 的核心部分"><a href="#AVL 的核心部分" class="headerlink" title="AVL 的核心部分"></a>AVL 的核心部分</h4><p>AVL 的核心部分即如何维护树的平衡。</p>
<h5 id="LL 型——右旋"><a href="#LL 型——右旋" class="headerlink" title="LL 型——右旋"></a>LL 型——右旋</h5><p>LL 表示 不平衡节点 y 的平衡因子为 2 且 y 的左孩子 x 节点的平衡因子 &gt;=0。此时又可以分成两种情况:</p>
<ul>
<li>y 节点的左孩子 x 的平衡因子为 1</li>
<li>y 节点的左孩子 x 的平衡因子为 0</li>
</ul>
<p>这两种情况都可以 对 y 节点 <strong>右旋</strong> 达到平衡</p>
<p><img src="https://api2.mubu.com/v3/document_image/72c0c34f-9391-4ecd-aac0-a07d85d37127-12259280.jpg" alt="img"></p>
<h5 id="对节点 -y 进行右旋 -rightRotate-Node-y"><a href="# 对节点 -y 进行右旋 -rightRotate-Node-y" class="headerlink" title="对节点 y 进行右旋 rightRotate(Node y)"></a>对节点 y 进行右旋 rightRotate(Node y)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 y 节点进行右旋转, 返回旋转后的新根节点 x, z 为新加入的节点, 导致 y 不平衡</span></span><br><span class="line"><span class="comment">//         y                               x</span></span><br><span class="line"><span class="comment">//       /  \          右旋转             /  \</span></span><br><span class="line"><span class="comment">//      x   T3       --------&gt;          T1    y</span></span><br><span class="line"><span class="comment">//     /  \                                  /  \</span></span><br><span class="line"><span class="comment">//    T1   T2                              T2   T3</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">rightRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.left;</span><br><span class="line">    Node T1 = x.left;</span><br><span class="line">    Node T2 = x.right;</span><br><span class="line">    Node T3 = y.right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    x.right = y;</span><br><span class="line">    y.left = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 height</span></span><br><span class="line">    <span class="comment">// 因为 x 随 y 改变而改变, 所以要先更新 y</span></span><br><span class="line">    y.height = <span class="number">1</span> + Math.max(getHeight(T2), getHeight(T3));</span><br><span class="line">    x.height = <span class="number">1</span> + Math.max(getHeight(T1), getHeight(y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RR 型"><a href="#RR 型" class="headerlink" title="RR 型"></a>RR 型</h5><p>RR 表示 不平衡节点 y 的平衡因子为 - 2 且 y 的右孩子 x 节点的平衡因子 &lt;=0。此时又可以分成两种情况:</p>
<ul>
<li>y 节点的右孩子 x 的平衡因子为 - 1</li>
<li>y 节点的右孩子 x 的平衡因子为 0</li>
</ul>
<p>上述情况都可以通过对 y 节点 <strong> 左旋 </strong> 达到平衡</p>
<p><img src="https://api2.mubu.com/v3/document_image/ff71ead0-b947-4006-a4ec-4220039fefc8-12259280.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 y 节点进行左旋转, 返回旋转后的新根节点 x</span></span><br><span class="line"><span class="comment">//      y                                   x</span></span><br><span class="line"><span class="comment">//    /  \            左旋转               /  \</span></span><br><span class="line"><span class="comment">//  T3     x         --------&gt;           y     T1</span></span><br><span class="line"><span class="comment">//        /  \                         /  \</span></span><br><span class="line"><span class="comment">//      T2    T1                     T3    T2</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">leftRotate</span><span class="params">(Node y)</span> </span>&#123;</span><br><span class="line">    Node x = y.right;</span><br><span class="line">    Node T1 = x.right;</span><br><span class="line">    Node T2 = x.left;</span><br><span class="line">    Node T3 = y.left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋转</span></span><br><span class="line">    x.left = y;</span><br><span class="line">    y.right = T2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 height</span></span><br><span class="line">    <span class="comment">// 因为 x 随 y 改变而改变, 所以要先更新 y</span></span><br><span class="line">    y.height = <span class="number">1</span> + Math.max(getHeight(T3), getHeight(T2));</span><br><span class="line">    x.height = <span class="number">1</span> + Math.max(getHeight(y), getHeight(T1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h5><p>LR 表示 不平衡节点 y 的平衡因子为 -2 且 y 的左孩子 x 节点的平衡因子 =- 1。这个条件包括多种情况 (下图中的 T2L 子树和 T2R 子树的高度有多种情况)， 但都可以通过<strong> 先左旋再右旋 </strong> 完成平衡化。具体操作如下图:</p>
<p><img src="https://api2.mubu.com/v3/document_image/06e4371d-730f-43e4-8c1a-69da8b69f044-12259280.jpg" alt="img"></p>
<h5 id="RL 型"><a href="#RL 型" class="headerlink" title="RL 型"></a>RL 型 </h5><p>RL 表示 不平衡节点 y 的平衡因子为 2 且 y 的右孩子 x 节点的平衡因子 =1。这个条件包括多种情况(下图中的 T2L 子树和 T2R 子树的高度有多种情况)， 但都可以通过<strong> 先右旋再左旋 </strong> 完成平衡化。具体操作如下图:</p>
<p><img src="/.com//Blog\myblog\source\_posts\AVL 树 \image-20211229103554821.png" alt="image-20211229103554821"></p>
<h4 id="什么时候需要维护平衡？"><a href="# 什么时候需要维护平衡？" class="headerlink" title="什么时候需要维护平衡？"></a>什么时候需要维护平衡？</h4><p>只有 <strong> 增加节点和删除节点的时候，树的高度才会改变，才可能打破平衡。</strong></p>
<h5 id="增加节点 -add-K-key-V-value- 方法"><a href="# 增加节点 -add-K-key-V-value- 方法" class="headerlink" title="增加节点　add(K key, V value) 方法"></a>增加节点　add(K key, V value) 方法 </h5><p> 公有的 add(K key, V value)方法和 BST 中一样，区别在于私有方法 add(Node node, K key, V value)，<strong>区别只在于每一次当前节点向上 return 之前需要调用 maintainBalance(Node node)方法，确保每一个节点在 return 之前是平衡的。</strong> <strong>这样一层层 return 上去，整个树也就平衡了</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中加入 e</span></span><br><span class="line"><span class="comment">// 并且返回 node</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) == <span class="number">0</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护平衡</span></span><br><span class="line">    <span class="keyword">return</span> maintainBalance(node);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="维护以 node 为根节点的树的平衡 -maintainBalance-Node-node- 方法"><a href="# 维护以 node 为根节点的树的平衡 -maintainBalance-Node-node- 方法" class="headerlink" title="维护以 node 为根节点的树的平衡　maintainBalance(Node node) 方法"></a>维护以 node 为根节点的树的平衡　maintainBalance(Node node) 方法</h5><p>　首先计算平衡因子，判断当前节点是否从处于 LL, LR, RR, RL 四种状态。若处于四种状态的一种，则进行左旋或者右旋维护平衡，然后 return node。若不处于在四种状态，说明当前节点 node 已经处于平衡状态，无需维护，直接 return。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maintainBalance</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 height</span></span><br><span class="line">    node.height = <span class="number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算平衡因子</span></span><br><span class="line">    <span class="keyword">int</span> balanceFactor = getBalanceFactor(node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若当前节点的平衡因子绝对值超过 1, 则需要平衡维护</span></span><br><span class="line">    <span class="comment">//LL</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LR</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span> &amp;&amp; getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = leftRotate(node.left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RR·</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RL</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &lt; -<span class="number">1</span> &amp;&amp; getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = rightRotate(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经平衡, 无需维护</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除最小节点 -removeMin-Node-node- 方法"><a href="# 删除最小节点 -removeMin-Node-node- 方法" class="headerlink" title="删除最小节点　removeMin(Node node) 方法"></a>删除最小节点　removeMin(Node node) 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除以 node 为根节点的树的最小节点, 并且返回 node</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node 的左子树被改变了, 需要维护 node 的平衡</span></span><br><span class="line">    <span class="keyword">return</span> maintainBalance(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除节点 -remove-Node-node- 方法"><a href="# 删除节点 -remove-Node-node- 方法" class="headerlink" title="删除节点　remove(Node node)方法"></a>删除节点　remove(Node node)方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node delNode = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (delNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = remove(root, key);</span><br><span class="line">        <span class="keyword">return</span> delNode.value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从以 node 为根节点的子树中删除, 并返回新树的根结点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = remove(node.left, key);</span><br><span class="line">        <span class="comment">//node 的左子树平衡可能被破坏了</span></span><br><span class="line">        <span class="keyword">return</span> maintainBalance(node);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = remove(node.right, key);</span><br><span class="line">        <span class="comment">//node 的右子树平衡可能被破坏了</span></span><br><span class="line">        <span class="keyword">return</span> maintainBalance(node);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//key==node.key 找到了被删除的节点</span></span><br><span class="line">		<span class="comment">// 待删除结点左孩子为空，用 node 结点的右孩子替代待删除节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">         <span class="comment">// 待删除结点右孩子为空，用 node 左孩子替代待删除节点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到待删除节点右子树中最小的节点(后继节点), 替代待删除节点的位置</span></span><br><span class="line">            Node successor = minimum(node.right);</span><br><span class="line">            successor.right = removeMin(node.right);<span class="comment">// 已经 size-- 了</span></span><br><span class="line">            successor.left = node.left;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//successor 在 removeMin 中删掉的时候已经维护了平衡</span></span><br><span class="line">            <span class="comment">//successor 替换被删去的 node 的位置, 就不用再维护平衡了,</span></span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除的逻辑</p>
<p>17-25 行：如何处理 return 上来的节点。只要 return 上来的子树发生了改变，那么当前节点 node 的平衡就有可能被打破。所以在将当前节点 node 返回给上一层节点时，需要 <strong> 维护以当前节点 node 为根节点的树的平衡，然后才能返回</strong></p>
<p>29-33 行：待删除结点左孩子为空，用 node 结点的右孩子替代待删除节点</p>
<p>34-38 行：待删除结点右孩子为空，用 node 左孩子替代待删除节点</p>
<p>39-47 行：找到待删除节点的后继节点，替代待删除节点</p>
<p>AVL 一般不会单独暴露给用户，而是以 Map 或 Set 的方式给用户调用</p>
<h4 id="AVL-Map"><a href="#AVL-Map" class="headerlink" title="AVL Map"></a>AVL Map</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span>  <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">IMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AVLTree1&lt;K,V&gt; avl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AVLMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        avl=<span class="keyword">new</span> AVLTree1&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        avl.add(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.contains(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        avl.set(key,newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> avl.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试一下"><a href="# 测试一下" class="headerlink" title="测试一下"></a>测试一下 </h5><p> 定义一个 AVLMapTest，利用一个文件处理类 FileOperation 读取一本英文书，然后将里面的英文单词放入 BSTMap 里面，我们特意增加了一个对比，拿 BST 和 AVL 做对比。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FileOperation.readFile(<span class="string">&quot;D:\\Data-Structures-and-Algorithms-zhc_dev\\AVLTree\\pride-and-prejudice.TXT&quot;</span>, words);</span><br><span class="line">        System.out.println(<span class="string">&quot;Total words : &quot;</span> + words.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试极端情况,BSTMap 退化成链表,AVLMap 依然稳定</span></span><br><span class="line">        <span class="comment">//Collections.sort(words);</span></span><br><span class="line"></span><br><span class="line">        AVLMap&lt;String, Integer&gt; avlMap = <span class="keyword">new</span> AVLMap&lt;&gt;();</span><br><span class="line">        BSTMap&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BSTMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 AVL 性能</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (avlMap.contains(word))</span><br><span class="line">                avlMap.set(word, avlMap.get(word) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                avlMap.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;AVL Map size : &quot;</span> + avlMap.getSize());</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            avlMap.remove(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">double</span> time = (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;AVL Map time : &quot;</span> + time + <span class="string">&quot; s.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;AVL Map size : &quot;</span> + avlMap.getSize());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 BST 性能</span></span><br><span class="line">        startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bstMap.contains(word))</span><br><span class="line">                bstMap.set(word, bstMap.get(word) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                bstMap.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;BST Map size : &quot;</span> + bstMap.getSize());</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            bstMap.remove(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        endTime = System.nanoTime();</span><br><span class="line">        time = (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;BST Map time : &quot;</span> + time + <span class="string">&quot; s.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;BST Map size : &quot;</span> + bstMap.getSize());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Total words : <span class="number">122758</span></span><br><span class="line">AVL Map size : <span class="number">6260</span></span><br><span class="line">AVL Map time : <span class="number">0.0826515</span> s.</span><br><span class="line">AVL Map size : <span class="number">0</span></span><br><span class="line">BST Map size : <span class="number">6260</span></span><br><span class="line">BST Map time : <span class="number">0.0812955</span> s.</span><br><span class="line">BST Map size : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>很意外的是，我们费了这么大的力气进行维护平衡，到头来竟然性能不如 BST。这是为什么呢？</p>
<p>这是因为 AVL 维护平衡的过程需要一定的性能开销。对于完全随机的数据，BST 性能已经足够好了，AVL 额外的平衡维护是一种负担。</p>
<p>那我们还要 AVL 做什么呢？</p>
<p><strong>AVL 的优势在于时时刻刻维护树的平衡，尤其是对于完全有序或是近似有序的数据，AVL 的时间复杂度都趋于稳定，而不像 BST。对于完全有序的数据, 可以想象 BST 的树型结构会退化成一个链表结构，导致时间复杂度越级成 O(N)。另外 AVL 在查询的时候性能非常稳定，因为整一棵树足够的平衡。</strong></p>
<p>测试极端情况：Collections.sort(words);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Total words : <span class="number">122758</span></span><br><span class="line">AVL Map size : <span class="number">6260</span></span><br><span class="line">AVL Map time : <span class="number">0.0584185</span> s.</span><br><span class="line">AVL Map size : <span class="number">0</span></span><br><span class="line">BST Map size : <span class="number">6260</span></span><br><span class="line">BST Map time : <span class="number">11.3459973</span> s.</span><br><span class="line">BST Map size : <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看到 BST 的时间增加了 137 倍，而 AVL 时间依然稳定，几乎不变。这就是 AVL 的优势所在。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>BST——二叉搜索树</title>
    <url>/2021/12/27/BST%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/BST%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>二叉搜索树是一种二叉树型数据结构，也是平衡二叉树 AVL 和红黑树的基础。二叉搜索树有几个重要的属性：</p>
<ul>
<li>key，键</li>
<li>val，key 所代表的值</li>
<li>left，左孩子</li>
<li>right，右孩子</li>
</ul>
<p>一棵二分搜索树可以用下面的图表示(其中的数字表示 key，val 没有表示出来)：</p>
<p><img src="https://api2.mubu.com/v3/document_image/53f551a0-5a5a-4148-89f6-be298b89ec7b-12259280.jpg" alt="img"></p>
<p>BST 主要有几个特点：</p>
<ul>
<li>左孩子节点.key &lt; 父节点.key &lt; 右孩子节点.key</li>
<li>二分搜索树中 key 不允许重复，value 可以重复</li>
<li>BST 的中序遍历是一个递增的序列</li>
</ul>
<h4 id="构造方法"><a href="# 构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>　成员变量主要有 Node 节点(内部类)、root(根节点)、size(节点个数)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> K key;</span><br><span class="line">        <span class="keyword">private</span> V value;</span><br><span class="line">        <span class="keyword">private</span> Node left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            left = <span class="keyword">null</span>;</span><br><span class="line">            right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 无参构造</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="常用方法"><a href="# 常用方法" class="headerlink" title="常用方法"></a>常用方法 </h5><h6 id="获取节点个数 getSize- 以及判断 BST 是否为空 -isEmpty"><a href="# 获取节点个数 getSize- 以及判断 BST 是否为空 -isEmpty" class="headerlink" title="获取节点个数 getSize() 以及判断 BST 是否为空 isEmpty()"></a>获取节点个数 getSize()以及判断 BST 是否为空 isEmpty()</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="根据 key 值查询某一节点是否存在 -contains-K-key"><a href="# 根据 key 值查询某一节点是否存在 -contains-K-key" class="headerlink" title="根据 key 值查询某一节点是否存在 contains(K key)"></a>根据 key 值查询某一节点是否存在 contains(K key)</h6><p>　一种常见的做法是写两个方法，一个 private 方法和一个 public 方法，这是封装的思想。封装就是把不想或者不该告诉别人的东西隐藏起来，把可以告诉别人的公开。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node root, K key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 节点为空，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到该节点，返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(root.key) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// key 值 &lt; root.key  说明要找的节点在 root 左子树，去左子树递归查找。</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.key) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root.left, key);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="根据 key 值获得一个节点 -get-K-key"><a href="# 根据 key 值获得一个节点 -get-K-key" class="headerlink" title="根据 key 值获得一个节点  get(K key)"></a>根据 key 值获得一个节点  get(K key)</h6><p>　思想跟 contains(K key)差不多</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getNode</span><span class="params">(Node root, K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(root.key) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(root.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root.left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(root.right, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="设置 key 值查找节点并设置节点的 value-set-K-key-V-newValue"><a href="# 设置 key 值查找节点并设置节点的 value-set-K-key-V-newValue" class="headerlink" title="设置 key 值查找节点并设置节点的 value  set(K key, V newValue)"></a>设置 key 值查找节点并设置节点的 value  set(K key, V newValue)</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 key 获取节点</span></span><br><span class="line">    Node node = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(key + <span class="string">&quot;doesn&#x27;t exist!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 赋新值</span></span><br><span class="line">        node.value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="minNode- 寻找二分搜索树中最小的元素的节点 - 并返回"><a href="#minNode- 寻找二分搜索树中最小的元素的节点 - 并返回" class="headerlink" title="minNode()寻找二分搜索树中最小的元素的节点, 并返回"></a>minNode()寻找二分搜索树中最小的元素的节点, 并返回</h6><p>　由 BST 的性质可知，BST 中最小的元素应该是树的最左边的叶子节点，因此一直向左子树递归找到最左边的叶子节点即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向左子树递归查找最小节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> minNode(node.left);</span><br><span class="line">    <span class="comment">// 找到了最左叶子节点，直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">minNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> minNode(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="add-K-key-V-value- 向 BST 中加入一个指定 key 的 val 的新节点"><a href="#add-K-key-V-value- 向 BST 中加入一个指定 key 的 val 的新节点" class="headerlink" title="add(K key, V value)向 BST 中加入一个指定 key 的 val 的新节点"></a>add(K key, V value)向 BST 中加入一个指定 key 的 val 的新节点 </h6><p>　private add(root, key, value) 从根节点向下 <strong> 寻找合适的位置添加新节点 </strong>。private add(Node node, K key, V value) 方法也是一个递归方法，<strong>当 node 为 NULL，说明找到了合适的位置 </strong>，新创创建一个 node 对象，size++。否则不断比较 key 和当前节点的 key。若 key 比 node.key 小，向左递归; 若 key 比 node.key 大，向右递归; <strong> 若 key 等于 node.key 则视为修改当前 node.value，因为 BST 中不允许存在重复的 key</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向二分搜索树中加入新节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    root = add(root, key, value);</span><br><span class="line">    <span class="comment">// add(root, key, value);  这么写是错误的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向以 node 为根的二分搜索树中加入新节点，并且返回 node</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该节点为空，直接添加节点</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不能存在相同的 key, 只能修改 value</span></span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) == <span class="number">0</span>) &#123;</span><br><span class="line">        node.value = value;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// key 值 &lt;node.key，在左子树中添加节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.right = add(node.right, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="removeMin-Node-node- 删除以 node 为根节点的最小节点 - 并返回 node"><a href="#removeMin-Node-node- 删除以 node 为根节点的最小节点 - 并返回 node" class="headerlink" title="removeMin(Node node) 删除以 node 为根节点的最小节点, 并返回 node"></a>removeMin(Node node) 删除以 node 为根节点的最小节点, 并返回 node</h6><p>　removeMin(Node node)是一个递归方法。首先处理递归到底的情况，若 node.left==null, 说明 node 就是最小节点，size—，将 node.right 备份成 rightNode, 将 node 指向 null， 最后返回 rightNode 给父节点.left。若没有递归到底，则继续向左递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除以 node 为根的二分搜索树中的最小节点，返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不为空，继续递归</span></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="comment">// 在删除完之后，没有影响的子树，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="public-V-remove-K-key- 给定 key 值删除某一个节点"><a href="#public-V-remove-K-key- 给定 key 值删除某一个节点" class="headerlink" title="public V remove(K key)给定 key 值删除某一个节点"></a>public V remove(K key)给定 key 值删除某一个节点 </h6><p> 删除 BST 节点可以分成三类情况来讨论:</p>
<ol>
<li>待删除节点 node 只有右孩子, 那么用右子树的根节点替换该节点，释放删除节点后，size—</li>
<li>待删除节点 node 只有左孩子, 那么用左子树的根节点替换该节点，释放删除节点后，size—</li>
<li><strong>待删除节点 node 既有左孩子，也有右孩子，有两种方法，一是找 node 节点的前驱 (node 左子树中的最大节点，preSuccessor 节点) 代替 node 节点，二是以 node 结点的后继 (node 右子树中的最小节点，Successor 节点) 代替 node 节点，这里使用第二种方式。</strong></li>
</ol>
<p><strong>第三种情况也就是最复杂的情况，用图表示如下:</strong></p>
<p><img src="https://api2.mubu.com/v3/document_image/f1bb763c-5151-4019-86bc-4d19ee6ad27c-12259280.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    Node delNode = getNode(root, key);</span><br><span class="line">    <span class="keyword">if</span> (delNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = remove(root, key);</span><br><span class="line">        <span class="keyword">return</span> delNode.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除以 node 为根的二分搜索树中值为 e 的节点，递归算法</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key.compareTo(node.key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = remove(node.left, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.compareTo(node.key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = remove(node.right, key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果左子树为空，右子树根节点替换该节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果右子树为空，左子树根节点替换该节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后继节点替代删除节点  还有前驱节点删除节点</span></span><br><span class="line">        <span class="comment">// 删除节点，左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">// 找到该节点的后继节点，用后继节点顶替待删除的节点位置</span></span><br><span class="line">        Node successor = minNode(node.right);</span><br><span class="line">        successor.right = removeMin(node.right);<span class="comment">// 返回的最小节点的根   已经 size-- 了</span></span><br><span class="line">        successor.left = node.left;</span><br><span class="line">        <span class="comment">// 释放 node 节点</span></span><br><span class="line">        node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　至此，我们已经实现了一个 BST 的重要功能。<strong>BST 一般不会单独暴露给用户，而是以 Map 或 Set 的方式给用户调用</strong></p>
<h4 id="BST-Map-amp-Set"><a href="#BST-Map-amp-Set" class="headerlink" title="BST Map &amp; Set"></a><strong>BST Map &amp; Set</strong></h4><h5 id="Map 的实现"><a href="#Map 的实现" class="headerlink" title="Map 的实现"></a>Map 的实现</h5><p>Map 的实现有多种方式，最简单的就是 BST，还有 AVL(平衡二叉树)， 红黑树，为了增强代码的复用性和解耦，我们不从头实现一个 Map。而是定义一个 Map 的接口, 去实现这个接口即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义 BSTMap 类来实现 Map 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTMap</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">K</span>&gt;, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">IMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BST&lt;K, V&gt; bst;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bst = <span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        bst.add(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.contains(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(K key, V newValue)</span> </span>&#123;</span><br><span class="line">        bst.set(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.getSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="测试一下"><a href="# 测试一下" class="headerlink" title="测试一下"></a>测试一下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; words = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        FileOperation.readFile(&quot;.//pride-and-prejudice.txt&quot;, words);</span></span><br><span class="line">        FileOperation.readFile(<span class="string">&quot;D:\\Data-Structures-and-Algorithms-zhc_dev\\AVLTree\\pride-and-prejudice.TXT&quot;</span>,words );</span><br><span class="line">        System.out.println(<span class="string">&quot;Total words : &quot;</span> + words.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试极端情况,BSTMap 退化成链表</span></span><br><span class="line"><span class="comment">//        Collections.sort(words);</span></span><br><span class="line"></span><br><span class="line">        BSTMap&lt;String, Integer&gt; bstMap = <span class="keyword">new</span> BSTMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 BST 性能</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bstMap.contains(word))</span><br><span class="line">                bstMap.set(word, bstMap.get(word) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                bstMap.add(word, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">        <span class="keyword">double</span> time = (endTime - startTime) / <span class="number">1000000000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;BST Map time : &quot;</span> + time + <span class="string">&quot; s.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;map size: &quot;</span> + bstMap.getSize());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Total words : <span class="number">122758</span></span><br><span class="line">BST Map time : <span class="number">0.0562629</span> s.</span><br><span class="line">map size: <span class="number">6260</span></span><br></pre></td></tr></table></figure>
<p>基于 BST 的 Map 性能是非常快的，但是 BST 有一个缺点，在极端情况下(比如插入关键字刚好有序)，此时 BST 会退化成链表，导致复杂度变高，也就是说 BST 不稳定。</p>
<p>我们将文本中的单词排序后 Collections.sort(words)再继续插入，看看结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Total words : <span class="number">122758</span></span><br><span class="line">BST Map time : <span class="number">11.33282</span> s.</span><br><span class="line">map size: <span class="number">6260</span></span><br></pre></td></tr></table></figure>
<p>由此可见，在极端情况下，基于 BST 的 Map 速度慢了接近 226 倍</p>
<h5 id="Set 的实现"><a href="#Set 的实现" class="headerlink" title="Set 的实现"></a>Set 的实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">implements</span> <span class="title">ISet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  BST&lt;E, Object&gt; bst;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bst=<span class="keyword">new</span> BST&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        bst.add(e,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        bst.remove(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.contains(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="测试一下 -1"><a href="# 测试一下 -1" class="headerlink" title="测试一下"></a>测试一下</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTSetTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; words  =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FileOperation.readFile(<span class="string">&quot;D:\\Data-Structures-and-Algorithms-zhc_dev\\AVLTree\\pride-and-prejudice.TXT&quot;</span>,words );</span><br><span class="line">        System.out.println(<span class="string">&quot;Total words : &quot;</span>+ words .size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试极端情况,BSTSet 退化成链表</span></span><br><span class="line">        <span class="comment">//Collections.sort(words);</span></span><br><span class="line"></span><br><span class="line">        BSTSet&lt;String&gt; bstSet=<span class="keyword">new</span> BSTSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 BST 性能</span></span><br><span class="line">        <span class="keyword">long</span> startTime=System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String word :words)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!bstSet.contains(word))</span><br><span class="line">                bstSet.add(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime=System.nanoTime();</span><br><span class="line">        <span class="keyword">double</span> time=(endTime-startTime)/<span class="number">1000000000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;BST Set time : &quot;</span>+ time+<span class="string">&quot; s.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total words : 122758</span><br><span class="line">BST Set time : 0.0247906 s.</span><br><span class="line">BST Set size: 6260</span><br></pre></td></tr></table></figure>
<p>同样的，将单词排序后插入，也就是 Collections.sort(words)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total words : 122758</span><br><span class="line">BST Set time : 4.1004937 s.</span><br><span class="line">BST Set size: 6260</span><br></pre></td></tr></table></figure>
<p>同理，在极端情况下，基于 BST 的 Set 速度慢了接近 205 倍，原因就是 BST 退化成了链表</p>
<h4 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h4><p>　BST 特性是左子树 &lt; 根 &lt; 右子树，因此中序遍历是一个递增的序列，在极端情况下，BST 会退化成一个有序的链表，此时查找复杂度从 O(logN) 变成 O(N)，因此性能有所下降。为了解决这个问题，AVL（平衡二叉树）诞生了。AVL 可以保持树的平衡，不会出现子树高度差距很大的情况，所以不会退化成链表，但是 AVL 缺点是可能会为了保持平衡从而进行大量的左旋和右旋操作，这在一定程度上也增大了开销。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
