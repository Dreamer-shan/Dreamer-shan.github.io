<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA基础</title>
    <url>/2021/10/16/JAVA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h5 id="为什么说Java是跨平台性的语言？"><a href="#为什么说Java是跨平台性的语言？" class="headerlink" title="为什么说Java是跨平台性的语言？"></a>为什么说Java是跨平台性的语言？</h5><p>&emsp;&emsp;跨平台性是指使用Java语言编写的程序，经过一次编译后，可以在不同操作系统上运行。其原理就是Java程序是通过Java虚拟机在操作系统上运行的，只要该操作系统安装了对应的Java虚拟机，这个系统就可以运行Java程序。<br>&emsp;&emsp;也就是说，Java程序只需要跟虚拟机打交道，与操作系统的交互都由虚拟机来负责。</p>
<span id="more"></span>

<h5 id="什么是字节码-为什么Java采用字节码呢"><a href="#什么是字节码-为什么Java采用字节码呢" class="headerlink" title="什么是字节码?为什么Java采用字节码呢?"></a>什么是字节码?为什么Java采用字节码呢?</h5><p>&emsp;&emsp;字节码是Java程序经过虚拟机编译后产生的代码，该代码不是面向处理器的，而是面向虚拟机的，也就是说编译后产生的字节码需要符合虚拟机规范。<br>&emsp;&emsp;正是因为采用了字节码，所以Java在一定程度上<strong>既解决了解释型语言执行速度慢的问题，又解决了解释型语言可移植性的特点</strong>。</p>
<h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python批量修改文件后缀名</title>
    <url>/2021/10/12/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_files_list</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    实现遍历dir目录下,所有文件(包含子文件夹的文件)</span></span><br><span class="line"><span class="string">    :param dir:指定文件夹目录</span></span><br><span class="line"><span class="string">    :return:包含所有文件的列表-&gt;list</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># parent:父目录, filenames:该目录下所有文件夹,filenames:该目录下的文件名</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;E:\test&quot;</span></span><br><span class="line">filelist = get_files_list(path)</span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> filelist:</span><br><span class="line">    portion = os.path.splitext(filename)  <span class="comment"># portion为名称和后缀分离后的列表</span></span><br><span class="line">    <span class="keyword">if</span> portion[<span class="number">1</span>] ==<span class="string">&quot;.bmp&quot;</span>:</span><br><span class="line">        newname = portion[<span class="number">0</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(filename)  <span class="comment"># 打印出要更改的文件名</span></span><br><span class="line">        os.chdir(path)</span><br><span class="line">        os.rename(filename, newname)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>跨平台性、编译型语言、解释型语言</title>
    <url>/2021/10/17/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h5 id="跨平台性是什么意思？"><a href="#跨平台性是什么意思？" class="headerlink" title="跨平台性是什么意思？"></a>跨平台性是什么意思？</h5><p>&emsp;&emsp;要知道，不同操作系统支持的函数、数据类型都可能不同，所以基于某个操作系统下编写的源代码一般是不能直接拿到另一个操作系统下编译的。注意<strong>我们所说的跨平台指的是源代码跨平台，而不是解释器跨平台</strong>。</p>
<span id="more"></span>

<h5 id="为什么说Java是跨平台性的语言？"><a href="#为什么说Java是跨平台性的语言？" class="headerlink" title="为什么说Java是跨平台性的语言？"></a>为什么说Java是跨平台性的语言？</h5><p>&emsp;&emsp;跨平台性是指使用Java语言编写的程序，经过一次编译后，可以在不同操作系统上运行。其原理就是Java程序是通过Java虚拟机在操作系统上运行的，只要该操作系统安装了对应的Java虚拟机，这个系统就可以运行Java程序。<br>&emsp;&emsp;也就是说，Java程序只需要跟虚拟机打交道，与操作系统的交互都由虚拟机来负责。</p>
<h5 id="编译型语言、解释型语言、混合型语言"><a href="#编译型语言、解释型语言、混合型语言" class="headerlink" title="编译型语言、解释型语言、混合型语言"></a>编译型语言、解释型语言、混合型语言</h5><p>&emsp;&emsp;计算机只能识别二进制指令，我们学习的Java、C++、Python都是高级语言，高级语言程序代码带运行之前要将源代码转换成二进制指令，也就是机器码，机器码是CPU可识别的硬件层面的代码。<br>&emsp;&emsp;那么，到底在何时将源代码转换成机器码呢?根据转换时机的不同，便有了不同类型的语言。</p>
<ul>
<li>编译型语言：提前将源代码通过<strong>编译器</strong>一次性全部转换成机器码，也就是生成一个可执行程序，比如windows下的.exe文件，常见的编译型语言有C、C++、Go、汇编语言<ul>
<li>优点：可以脱离开发环境运行，比如window下，通过编译后生成.exe可执行文件，可执行文件所包含的就是机器码，只要拥有了可执行程序就可以到处运行，不需要再重新编译了（不需要源代码和编译器了），可以做到<strong>一次编译，无限次运行</strong>。</li>
<li>缺点：可移植性差，因为不同操作系统的可执行文件几乎不兼容。</li>
</ul>
</li>
<li>解释型语言：通过<strong>解释器</strong>一边执行一边转换，<strong>解释型语言不会生成可执行程序</strong>，常见的解释型语言有Python、Matlab<ul>
<li>优点:可移植性好，因为有了中间层：<strong>解释器</strong>，官方针对不同操作系统开发不同的解释器，使得同样的源代码在不同操作系统下的执行结果是完全相同的。故解释型语言天生具有良好的可移植性。</li>
<li>缺点：相对编译型语言来说，解释型语言执行效率比较慢，甚至存在量级上的差距。</li>
</ul>
</li>
<li>混合型语言：半编译半解释，先将源代码转换成一种中间文件（在Java中就是字节码文件），然后再将中间文件拿到虚拟机中执行。常见的有Java、C#</li>
</ul>
<p>&emsp;&emsp;当我们说“下载一个程序（软件）”时，不同类型的语言有不同的含义：</p>
<p>&emsp;&emsp;&emsp;&emsp;对于编译型语言，我们下载到的是可执行文件，源代码被作者保留，所以编译型语言的程序一般是<strong>闭源</strong>的。</p>
<p>&emsp;&emsp;&emsp;&emsp;对于解释型语言，我们下载到的是所有的源代码，因为作者不给源代码就没法运行，所以解释型语言的程序一般是<strong>开源</strong>的</p>
<p>&emsp;&emsp;编译型语言和解释型语言的执行流程如下图所示：</p>
<p><img src="/2021/10/17/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%80%A7%E3%80%81%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/1.jpg" alt="编译型语言和解释型语言的执行流程"></p>
<p>&emsp;&emsp;有次面试被问到过<strong>Java和Python的区别</strong>，当时只答了一些语法层面，还有强类型语言弱类型语言的东西，包括垃圾回收机制（Python也是有自动垃圾回收的，而且用的是引用计数法）。面试官说我理解得不够深刻，我想他应该是想让我从这个层面来说吧。</p>
]]></content>
      <tags>
        <tag>语言类型的差异</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM复习</title>
    <url>/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="Java和C-的一个重要区别"><a href="#Java和C-的一个重要区别" class="headerlink" title="Java和C++的一个重要区别"></a>Java和C++的一个重要区别</h4><p>&emsp;&emsp;Java和C++都是面向对象的，但是C++需要程序员手动开辟(malloc)和回收(free)内存，但是有了JVM内存管理的存在，所以Java不需要程序员手动释放内存，在一定程度上减少了内存泄漏问题。</p>
<span id="more"></span>

<h4 id="为什么需要JVM？"><a href="#为什么需要JVM？" class="headerlink" title="为什么需要JVM？"></a>为什么需要JVM？</h4><p>&emsp;&emsp;Java语言最大的特点就是可移植性。也就是一次编译，到处运行。所有的程序并不是直接运行在操作系统上，而是通过JVM执行。</p>
<p>&emsp;&emsp;优点：减少了开发的难度，兼容不同操作系统。</p>
<p>&emsp;&emsp;缺点：比直接在操作系统上执行的程序的运行速度要慢。在早期这确实是一个问题，但是由于硬件技术的发展，这些问题一直在优化。</p>
<h4 id="JVM运行时数据区"><a href="#JVM运行时数据区" class="headerlink" title="JVM运行时数据区"></a>JVM运行时数据区</h4><p>&emsp;&emsp;JVM运行时数据区分为堆和方法区（<strong>线程共享</strong>）、虚拟机栈、本地方法栈、程序计数器（<strong>线程私有</strong>）。<img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/a.png" alt="JVM运行时数据区"></p>
<p>&emsp;&emsp;堆：内存中最大的一块，<strong>几乎</strong>所有的对象实例和数组都分配在堆中。<strong>注意是几乎，而不是全部。</strong>由于编译技术的进步，逃逸分析技术的发展，现在也存在<strong>栈上分配</strong>的情况。</p>
<p>&emsp;&emsp;方法区：用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量</strong>、即时编译器编译后的代码缓存等数据，<strong>运行时常量池也位于方法区中</strong>。</p>
<p>&emsp;&emsp;虚拟机栈：虚拟机栈的生命周期与线程相同。每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。当栈深度大于虚拟机栈所允许的深度，会抛出<strong>StackOverflowError</strong>异常。如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<strong>OutOfMemoryError</strong>异常。</p>
<p>&emsp;&emsp;本地方法栈：与虚拟机栈的作用，虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为虚拟机使用到的本地（Native）方法服务。</p>
<p>&emsp;&emsp;程序计数器：可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，代码的分支、循环、跳转、异常处理、线程恢复，都需要依赖这个计数器来完成。此内存区域是唯一一个在《Java虚拟机规范》中<strong>没有规定任何OutOfMemoryError</strong>情况的区域。</p>
<h4 id="new一个对象的时候会发生什么？"><a href="#new一个对象的时候会发生什么？" class="headerlink" title="new一个对象的时候会发生什么？"></a>new一个对象的时候会发生什么？</h4><p>&emsp;&emsp;Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到 一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，先要执行类加载过程。也就是加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载。</p>
<p>&emsp;&emsp;类加载通过后，虚拟机需要为新对象<strong>分配内存</strong>。对象的内存大小在<strong>类加载完成后就可以确定</strong>。根据内存是否规整，分配内存有两种方式。内存规整时使用指针碰撞方式，不规整时使用空闲列表方式。</p>
<p>​        &emsp;&emsp;指针碰撞：维护一个指针作为可用内存空间和不可用内存空间的分界点。内存分配就是将这个指针向着空闲内存的方向移动一段与对象内存大小相等的距离。Serial、ParNew收集器有空间压缩整理的能力（标记复制or整理算法），故这两款收集器使用指针碰撞方式来分配内存。</p>
<p>&emsp;&emsp;&emsp;&emsp;空闲列表：维护一个列表来记录哪些内存块是可用的，在分配内存时，从列表中找到一块足够大的空间划分给对象实例。CMS收集器使用的是标记清除法，理论上内存是不规整的，所以使用空闲列表的方式来分配内存。</p>
<p>&emsp;&emsp;在并发情况下，即使只是修改一个指针所指向的位置，也不一定是线程安全的。可能会出现这种情况：给对象A分配内存时，指针还没来得及修改，对象B使用了原来的指针分配内存。解决这个问题 有两种可选方案：</p>
<ul>
<li><strong>对分配内存空间的动作进行同步处理</strong>——实际上虚拟机是采用<strong>CAS+失败重试</strong>的方式保证更新操作的原子性；</li>
<li>内存分配的动作<strong>按照线程划分在不同的空间之中进行</strong>，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定</li>
</ul>
<p>&emsp;&emsp;内存分配完了之后，虚拟机会为对象初始化零值。还要对对象进行必要的设置，例如类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>&emsp;&emsp;对象定位主要有两种方式：句柄访问和直接指针访问</p>
<ul>
<li>句柄访问：从堆中划分一块内存作为句柄池，reference中存放着句柄地址，句柄中存放着对象实例数据与类型数据的具体地址信息。<ul>
<li>特点：当对象被移动时，只会改变句柄池中的<strong>实例数据指针</strong>，<strong>reference本身并不需要被修改</strong>。<strong>多了一次间接访问的开销</strong><img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/c.png" alt="句柄访问对象"></li>
</ul>
</li>
<li>直接指针：<ul>
<li>速度更快，节省了一次指针定位的开销。<img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/d.png" alt="直接指针访问对象"></li>
</ul>
</li>
</ul>
<hr>
<h4 id="垃圾回收理论和垃圾回收器"><a href="#垃圾回收理论和垃圾回收器" class="headerlink" title="垃圾回收理论和垃圾回收器"></a>垃圾回收理论和垃圾回收器</h4><p>&emsp;&emsp;垃圾回收要考虑的三件事：哪些内存需要回收、何时回收、怎么回收</p>
<ul>
<li><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭</strong>，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此<strong>这几个区域的内存分配和回收都具备确定性</strong>，在这几个区域内就不需要过多考虑如何回收的问题，<strong>当方法结束或者线程结束时，内存自然就跟随着回收了。</strong></li>
<li>而<strong>Java堆和方法区</strong>这两个区域则有着很显著的不确定性：只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，<strong>这部分内存的分配和回收是动态的。</strong></li>
</ul>
<h5 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h5><p>&emsp;&emsp;在垃圾回收之前，最先要确定的就是哪些对象还存活，哪些对象已经死去（需要回收）。判断对象是否存活主要有两种算法：引用计数法和可达性分析。</p>
<ul>
<li>引用计数法：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一。当引用失效时，计数器值就减一；<ul>
<li>Python在对象回收时就使用了引用计数法。</li>
<li>特点：原理简单，判定效率高。但是难以解决对象之间相互引用的问题（此时需要配合大量额外处理才能保证正确地工作）。</li>
</ul>
</li>
<li>可达性分析：通过GC Roots根对象作为起始节点集，若GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的<img src="/2021/10/11/JVM%E5%A4%8D%E4%B9%A0/e.png" alt="可达性分析"></li>
</ul>
<h5 id="可作为GC-Roots的对象"><a href="#可作为GC-Roots的对象" class="headerlink" title="可作为GC Roots的对象"></a>可作为GC Roots的对象</h5><ul>
<li>在<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 </li>
<li>在方法区中<strong>类静态属性引用的对象</strong>，譬如Java类的引用类型静态变量。</li>
<li>在方法区中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</li>
</ul>
<h5 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h5><p>&emsp;&emsp;在JDK1.2之前，Java引用就是传统定义，一个对象在这种定义下只有“被引用”或者“未被引用”两种状态未免有点过于狭隘。如果我们希望描述一类对象：当<strong>内存空间还足够时，能保留在内存之中</strong>，如果内存空间在进行垃圾收集后<strong>仍然非常紧张，那就可以抛弃这些对象</strong>。</p>
<p>&emsp;&emsp;在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用</p>
<ul>
<li>强引用：类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象</li>
<li>软引用：<strong>还有用，但非必须的对象</strong>。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，<strong>如果这次回收还没有足够的内存， 才会抛出内存溢出异常</strong></li>
<li>弱引用：非必须对象，但是它的强度比软引用更弱一些，<strong>无论当前内存是否足够，都会回收掉只被弱引用关联的对象</strong></li>
<li>虚引用：为一个对象设置虚引用关联的<strong>唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</strong></li>
</ul>
<h5 id="finalize-方法？"><a href="#finalize-方法？" class="headerlink" title="finalize()方法？"></a>finalize()方法？</h5><p>&emsp;&emsp;要宣告一个对象的死亡至少要经历两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。如果有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中。稍后虚拟机会创建一个线程去筛选F-Queue中的对象。</p>
<p>&emsp;&emsp;finalize()方法只会执行1次——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量。<strong>在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</strong></p>
<h5 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h5><p>&emsp;&emsp;<font color="#FF0000">  方法区实际上是有垃圾回收的。 </font>方法区的垃圾收集主要回收两部分内容：<strong>废弃的常量和不再使用的类型。</strong></p>
<ul>
<li>废弃常量：假如 “ABC” 在常量池中，但是现在没有任何字符串对象引用常量池中的 “ABC” 常量，如果在这时发生内存回收，这个 “ABC” 常量就将会被系统清理出常量池。<strong>常量池中其他类（接 口）、方法、字段的符号引用也与此类似。</strong></li>
</ul>
<h5 id="判定一个类型是否属于“不再被使用的类”的条件"><a href="#判定一个类型是否属于“不再被使用的类”的条件" class="headerlink" title="判定一个类型是否属于“不再被使用的类”的条件"></a>判定一个类型是否属于“不再被使用的类”的条件</h5><p>&emsp;&emsp;判定一个类是否属于==不再被使用的类==需要同时满足三个条件 <font color="red">asdsad</font></p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </li>
<li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。 </li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h5 id="垃圾回收的几个假说-垃圾回收的前提-："><a href="#垃圾回收的几个假说-垃圾回收的前提-：" class="headerlink" title="垃圾回收的几个假说(垃圾回收的前提)："></a>垃圾回收的几个假说(垃圾回收的前提)：</h5><ul>
<li><p>弱分代假说：绝大多数对象都是==朝生夕灭==的</p>
</li>
<li><p>强分代假说：熬过越多次垃圾收集过程的对象就==越难以消亡==</p>
</li>
<li><p>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</p>
<p>基于前两个假说，垃圾收集器有了一下原则：</p>
<ul>
<li>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储，也就是<strong>新生代和老年代</strong></li>
</ul>
<p>基于第三个假说，我们就<strong>不应再为了少量的跨代引用去扫描整个老年代</strong>，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为<strong>“记忆集”</strong>），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有<strong>包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</strong>。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但<strong>比起收集时扫描整个老年代来说仍然是划算的</strong>。</p>
</li>
</ul>
<h5 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h5><p>&emsp;&emsp;首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。</p>
<p>&emsp;&emsp;特点：</p>
<ul>
<li>执行效率不稳定（如果有大量对象需要回收的话，需要进行大量的标记和清除的动作）</li>
<li>会导致内存空间的碎片化问题，导致分配大对象时由于<strong>无法找到足够大的连续内存空间而提前触发另一次垃圾回收</strong>。</li>
</ul>
<h5 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h5><p>&emsp;&emsp;半区复制：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>&emsp;&emsp;特点：1.内存规整，不会产生空间碎片问题，但是如果多数对象存活，会产生大量的内存复制间的开销。2.内存利用率低，可用内存缩小为了原来的一半。</p>
<p>&emsp;&emsp;==改进==：根据新生代对象朝生夕死的特点，把新生代分为Eden区和S1区、S2区。默认比例是8：1：1</p>
<h5 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h5><p>&emsp;&emsp;标记过程与标记清除一样，然后让所有存活对象==都向内存空间一端移动==，再直接清理掉边界以外的内存。</p>
<p>&emsp;&emsp;标记整理和标记清除的区别在于，标记整理是==移动式回收算法==，标记清理是非移动式算法。==对象移动操作必须全程暂停用户应用程序才能进行，也就是STW==</p>
]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
