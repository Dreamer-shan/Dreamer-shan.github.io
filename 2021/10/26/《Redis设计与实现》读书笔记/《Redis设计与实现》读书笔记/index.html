<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!--pjax：防止跳转页面音乐暂停-->
 <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis中的数据结构字符串&amp;emsp;&amp;emsp;简单动态字符串的结构：使用一个结构体来表示，其内部有一个buf数组(保存字符串)，以及字符串长度len，剩余长度free等字段，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Redis 设计与实现》读书笔记">
<meta property="og:url" content="http://example.com/2021/10/26/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Dreamer-shan&#39;s Blog">
<meta property="og:description" content="Redis中的数据结构字符串&amp;emsp;&amp;emsp;简单动态字符串的结构：使用一个结构体来表示，其内部有一个buf数组(保存字符串)，以及字符串长度len，剩余长度free等字段，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/aef323e1-d81e-45b5-bc34-78f82fca759f-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/d531493d-261f-42e3-a5d0-a1249a3655d9-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/81fcb70e-7b3e-4d79-b919-4262e4695044-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/a41abab9-9440-4535-b78d-7475be0c171b-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/f104c56b-d380-44cd-a64a-28fb51eeba76-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/81d2b496-b86c-4d50-8900-c95034f36dc1-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/2ce1d861-37a6-4e50-bd6a-f31a52b72403-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/d5280468-3589-4c38-8a7a-c457c4c0c608-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/cf9cb1d2-8ec5-4026-b32c-e8c7f22db422-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/ea8f1d97-b799-4ee3-ace2-d64bc5598109-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/4dbbfdf9-4dfe-41f1-a0b2-f3fc8c0a1ddd-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/5b934ef8-c434-473d-88d0-faa17f1821e1-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/79cb9883-2f79-4a5b-8a0f-60e0eebc74ab-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/81d85ea8-e660-4a79-b3fa-b4ffb356ee94-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/0089123b-1ace-428f-8d52-dd5d37c830be-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/135f9792-2877-463e-9054-7cb6d49022f1-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/f7d5cbc6-ea87-4ae1-8a78-f74561e57503-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/0502a38d-b4a5-42a7-bde5-666c372ded94-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/00a7b512-8ce2-4aab-a504-12e4d5887aa6-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/799f8eb4-35cb-453c-b135-d8cb51f5a0a3-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/42cee358-df0c-4e1d-b0f1-655e92f976d1-12259280.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/ea429ae5-bc25-492b-b584-303d4c5c7e76-12259280.jpg">
<meta property="article:published_time" content="2021-10-26T06:57:39.000Z">
<meta property="article:modified_time" content="2021-11-09T02:30:01.299Z">
<meta property="article:author" content="Dreamer-shan">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/aef323e1-d81e-45b5-bc34-78f82fca759f-12259280.jpg">

<link rel="canonical" href="http://example.com/2021/10/26/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Redis 设计与实现》读书笔记 | Dreamer-shan's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dreamer-shan's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="history fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="list fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/26/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ARedis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Dreamer-shan">
      <meta itemprop="description" content="吃西瓜不吐西瓜皮，不吃葡萄倒吐葡萄皮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dreamer-shan's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Redis 设计与实现》读书笔记
        </h1>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-26 14:57:39" itemprop="dateCreated datePublished" datetime="2021-10-26T14:57:39+08:00">2021-10-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-09 10:30:01" itemprop="dateModified" datetime="2021-11-09T10:30:01+08:00">2021-11-09</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h5 id="Redis 中的数据结构"><a href="#Redis 中的数据结构" class="headerlink" title="Redis 中的数据结构"></a>Redis 中的数据结构 </h5><h6 id="字符串"><a href="# 字符串" class="headerlink" title="字符串"></a> 字符串</h6><p>&emsp;&emsp; 简单动态字符串的结构：使用一个结构体来表示，其内部有一个<strong>buf 数组(保存字符串)，以及字符串长度 len，剩余长度 free 等字段</strong>，优点是通过长度限制写入，避免缓冲区溢出，另外剩余长度不足时会自动扩容，扩展性较好，不需要频繁分配内存。</p>
<span id="more"></span>
<p><img src="https://api2.mubu.com/v3/document_image/aef323e1-d81e-45b5-bc34-78f82fca759f-12259280.jpg" alt="img"></p>
<p>&emsp; 简单动态字符串 (SDS) 与 C 语言字符串的区别</p>
<ul>
<li><p>1. 常数复杂度获取字符串长度</p>
<ul>
<li>len 表示已经使用字节的数量 (也就是字符串的长度，这样就可以 O(1) 复杂度获取字符串的长度)</li>
<li>即使对一个非常长的字符串键执行 strlen 命令，也不会对系统性能造成影响，因为 strlen 复杂度仅为 O(1)</li>
</ul>
</li>
<li><p>2. 杜绝缓冲区溢出</p>
<p><img src="https://api2.mubu.com/v3/document_image/d531493d-261f-42e3-a5d0-a1249a3655d9-12259280.jpg" alt="img"></p>
<ul>
<li>C 字符串不记录自身长度带来的一个问题是容易造成缓冲区溢出：执行 strcat 时如果忘记分配足够空间，s1 的数据就会溢出到 s2 所在的空间中  如图，执行 strcat 之前没有分配足够空间，s1 就变成了 rediscluster，也就是 s1 的内容溢出到了 s2 所在位置<img src="https://api2.mubu.com/v3/document_image/81fcb70e-7b3e-4d79-b919-4262e4695044-12259280.jpg" alt="img"></li>
<li>SDS 空间分配策略：需要对 SDS 进行修改时，<strong>先会检查 SDS 的空间是否满足修改所需的要求，不满足要求的话就先拓展 SDS 的空间</strong>，再执行 sdscat 拼接操作</li>
</ul>
</li>
<li><p>3. 减少修改字符串时带来的内存重分配次数</p>
<ul>
<li><p>对于一个包含了 N 个字符的 C 字符串来说，底层实现总是一个 N+1 个字符长的数组(‘\0’作为结束标志)，所以每次增长或者缩短 C 字符串，都要对保存这个 C 字符串的数组进行内存重分配操作。</p>
<ul>
<li><p>如果是拼接操作 append，执行这个操作之前，程序先要内存重分配来扩展底层数组的大小——如果忘了这一步就会产生 <strong> 缓冲区溢出</strong></p>
</li>
<li><p>如果是裁剪操作 trim，执行这个操作之后，程序需要内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生 <strong> 内存泄露</strong></p>
</li>
</ul>
</li>
<li><p>在一般程序中，如果修改字符串长度的情况不经常出现，那么每次修改都执行一次内存重分配是可以接受的，但是<strong>redis 作为数据库，经常被用于速度要求严苛、数据被频繁修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话</strong>，内存重分配的时间就会占据修改字符串所用时间段一大部分，如果频繁修改还可能对性能造成影响。</p>
</li>
</ul>
</li>
<li><p>4. 减少内存分配次数采取的策略：<strong>空间预分配 </strong> 以及 <strong> 惰性空间释放</strong></p>
<ul>
<li>空间预分配：<ul>
<li>修改后的 SDS&lt;1MB，程序分配和 len 属性同样大小的未使用空间，此时 SDS 的 len 与 free 大小相等。比如修改后实际存储字符串的空间变为 13 字节，那么 len=13，free=13，buf 数组整体的长度 =13+13+1=27（额外 1 字节保存结束符）</li>
<li>修改后 SDS&gt;=1MB。程序会分配 1MB 的未使用空间。比如修改后实际存储字符串的空间变为 2MB，那么 len=2M，free=1MB，buf 数组整体的长度 =2MB+1MB+1byte</li>
</ul>
</li>
<li>惰性空间释放：用于优化 SDS 字符串 <strong> 缩短操作 </strong>。当 SDS API 需要缩短保存的字符串时，程序并<strong> 不立即回收这部分内存，而是使用 free 属性将字节的数量记录，等待使用。</strong>与此同时，SDS 提供了相关 API，<strong>在有需要时，真正释放未使用空间</strong></li>
</ul>
</li>
</ul>
<h6 id="字符串总结"><a href="# 字符串总结" class="headerlink" title="字符串总结"></a>字符串总结 <img src="https://api2.mubu.com/v3/document_image/a41abab9-9440-4535-b78d-7475be0c171b-12259280.jpg" alt="img"></h6><h6 id="链表"><a href="# 链表" class="headerlink" title="链表"></a> 链表 </h6><p> 双向链表结构，使用 adlist.h/list 来持有，操作链表<img src="https://api2.mubu.com/v3/document_image/f104c56b-d380-44cd-a64a-28fb51eeba76-12259280.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/81d2b496-b86c-4d50-8900-c95034f36dc1-12259280.jpg" alt="img"></p>
<p>链表总结</p>
<ul>
<li>双端：链表节点带有 prev 和 next 指针，获取前置和后置节点的复杂度都是 O(1)</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。 带表头指针和表尾指针，带链表长度计数器 </li>
<li>头尾指针：将程序获取头尾节点的复杂度降为 O(1)</li>
<li>长度计数器：将程序获取表长的复杂度降为 O(1)</li>
<li>多态：链表节点使用 void* 指针来保存节点值，并且可以通过 list 结构的 dup、free、match 为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li>
</ul>
<h6 id="字典"><a href="# 字典" class="headerlink" title="字典"></a>字典</h6><p>&emsp; 数组中的每个元素都是指向 dict.h/dictht 的结构，dictEntry 就是一个键值对<img src="https://api2.mubu.com/v3/document_image/2ce1d861-37a6-4e50-bd6a-f31a52b72403-12259280.jpg" alt="img"></p>
<p>Redis 中的字典由 dict.h/dict 实现，由这个数据结构将字典组织在一起</p>
<p><img src="https://api2.mubu.com/v3/document_image/d5280468-3589-4c38-8a7a-c457c4c0c608-12259280.jpg" alt="img"></p>
<ul>
<li>ht 属性是包含两个项的数组，<strong>每项都是一个哈希表 </strong>，<strong>ht[0] 平时使用，而 ht[1]仅在 rehash 时使用</strong>。</li>
<li>rehashidx 记录了 rehash 的进度，初始为 -1</li>
<li>解决键冲突：链地址法，为了提高速度，每次都是 <strong> 将新节点添加到链表的表头位置</strong>，复杂度为 O(1)（这点跟 hashmap 不一样）</li>
</ul>
<p>rehash 的过程</p>
<ul>
<li>1. 为字典 ht[1]哈希表分配空间，大小取决于要执行的操作与 ht[0]当前键值对的数量，将保存在 ht[0]中的所有键值对存放到 ht[1]指定的位置</li>
<li>2. 当 ht[0]的所有键值对都迁移完毕后，释放 ht[0]，并指向 ht[1]，并在 ht[1]上创建一个空的哈希表，为下次 rehash 准备。</li>
</ul>
<p>扩容的条件</p>
<ul>
<li>服务器目前 <strong> 没有在执行 </strong>BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的<strong> 负载因子 &gt;=1</strong></li>
<li>服务器 <strong> 正在执行 </strong>BGSAVE 命令或 BGREWRITEAOF 命令，并且哈希表的<strong> 负载因子 &gt;=5</strong></li>
</ul>
<p>为什么根据 BGSAVE 命令或 BGREWRITEAOF 命令来判断是否扩展？</p>
<ul>
<li>执行这些命令时，Redis 需要创建当前服务器进程的子进程，大多数操作系统采用 <strong> 写时复制技术 </strong> 来优化子进程使用效率，此时提高负载因子，可以尽量避免子进程对哈希表扩展，避免不必要的内存写入操作，节约内存。</li>
<li>Redis 在持久化时，如果是采用 BGSAVE 命令或者 BGREWRITEAOF 的方式，那 Redis 会 <strong>fork 出一个子进程来读取数据，从而写到磁盘中</strong>。如果子进程存在期间，发生了大量的写操作，那可能就会出现很多的分页错误(页异常中断 page-fault)，这样就得耗费不少性能在复制上。<strong> 而在 rehash 阶段上，写操作是无法避免的。</strong>所以 Redis 在 fork 出子进程之后，将负载因子阈值提高，尽量减少写操作，避免不必要的内存写入操作，最大限度地节约内存。</li>
</ul>
<p>渐进式 hash</p>
<ul>
<li>rehash 时会将 ht[0]中所有的键值对 rehash 到 ht[1]，如果 <strong> 键值对很多并且一次性操作的话，容易导致服务器在一段时间内停止服务 </strong>。为避免这种情况，Redis 采用渐进式 rehash，将 ht[0] 中的键值对 <strong> 分多次，慢慢的 rehash 到 ht[1]之中</strong>。</li>
</ul>
<p>渐进式 hash 的步骤</p>
<ul>
<li>1. 为 ht[1]分配空间，让字典同时持有两个哈希表。</li>
<li>2. 在字典中维持一个索引计数器变量 rehashidx，将其设置为 0，表示 rehash 正式开始。</li>
<li>3. 在 rehash 进行期间，每次对字典进行添加，删除，查找或更新操作时，程序除了执行指定的操作外，还会将 ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成后，将 rehashidx++。</li>
<li>4. 某个时刻，ht[0]中的所有键值对都被 rehash 至 ht[1]，此时设置 rehashidx= -1 时，表示 rehash 操作已经完成。</li>
</ul>
<p>渐进式 hash 的好处</p>
<p>&emsp; 采用了分而治之的方式，将 rehash 键值对所需的计算工作均摊到对字典的每个操作中，从而避免集中式 rehash 带来庞大计算量</p>
<p>&emsp; 在 rehash 的期间，字典同时使用 ht[0]，ht[1]两个哈希表。对哈希表的操作会在两个表上进行，比如查找键时，<strong>先在 ht[0]里面查找，如果为空，就继续到 ht[1]里查找 </strong>。在此期间，<strong> 新增的键值对都会被添加到 ht[1]中 </strong>，ht[0] 不承担任何添加操作，<strong>保证 ht[0]中的键值对只能是越来越少</strong>。</p>
<h6 id="跳表"><a href="# 跳表" class="headerlink" title="跳表"></a>跳表 </h6><p>　跳跃表是一种<strong> 有序的 </strong> 数据结构，通过在每个节点 <strong> 维持多个指向其他节点的指针</strong>，达到快速访问节点的目的。Redis 只有在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中作为内部数据结构。</p>
<p><img src="https://api2.mubu.com/v3/document_image/cf9cb1d2-8ec5-4026-b32c-e8c7f22db422-12259280.jpg" alt="img"></p>
<p><img src="https://api2.mubu.com/v3/document_image/ea8f1d97-b799-4ee3-ace2-d64bc5598109-12259280.jpg" alt="img"></p>
<p>　1. 层—level</p>
<p>　　跳跃表的每个节点都会包含多个层，每次创建一个新跳跃表时，都会根据 <strong> 幂次定律</strong>，随机生成一个<strong>1~32 之间的数作为层的大小</strong>。每个层都会包含前进指针和跨度</p>
<p>　2. 前进指针（forword）</p>
<p>　　用于访问下一个节点。跨度表示两个节点之间的距离，指向 NULL 的所有前进指针的跨度为 0。跨度用于计算排位，访问某一结点的 <strong> 经过的跨度之和就是当前节点的排位</strong></p>
<p>　3. 后退指针—backward</p>
<p>　　用于从表尾向表头方向访问节点，<strong>前进指针可以一次跳过多个节点 </strong>，<strong> 后退指针只能后退至前一个节点</strong>，因为每个节点只有一个后退指针。</p>
<p>　4. 分值—score</p>
<p>　　分值是一个 double 类型的浮点数，跳跃表中节点都按照分值排序。</p>
<p>　5. 成员对象—obj</p>
<p>　　是一个指针，指向字符串 SDS 对象。一个跳跃表中，对象必须是唯一的，但分值可以相同。相同时按对象字典序来排序。</p>
<p>　Redis 的 level 个数 <strong> 为什么要用幂次定律生成</strong>（随机生成节点的层数）？</p>
<p>　　通过幂次定律能保证 <strong> 越高 level 的结点数量越少 。保证索引等级越高，参与索引建立的元素越少，如果每层都有很多 level，那么这个索引建立的就没有意义了。</strong></p>
<p>　为什么不用最均衡的方式，按照节点分数的排序情况均匀建立索引？</p>
<p>　　考虑到下一个插入的元素具有随机性，这样设计不容易出现最坏的情况。如果每次都以均匀固定的方式建索引，维护的成本很高，跳跃表的优点就是维持结构平衡的成本低，完全依靠随机。跳跃表相比二叉树有一个优势就在于不需要主动 rebalance 去维护平衡。</p>
<p>　跳表的查找过程</p>
<p>　　此时跳跃表查找 10，会先从 header 节点（O1）的最高层（L3）寻找，发现要查找的数小于 23.２则返回，继续从下一个有后继的层开始寻找，当发现要查找的数小于 11.0 时，则从 O1 的下一层找，此时到 O2 的 L1，发现要查找的数大于 7.0，则从 L1 找，直到查找到相邻节点为止。<img src="https://api2.mubu.com/v3/document_image/4dbbfdf9-4dfe-41f1-a0b2-f3fc8c0a1ddd-12259280.jpg" alt="img"></p>
<p>　为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>　　如果 <strong> 只使用字典存储，由于是无序的，所以每次在范围查询时，需要排序 </strong>，时间复杂度 O(nlogn) 为和额外 O(n)  的内存空间，因为要创建一个数组存储排序后的元素。 如果 <strong> 只用跳跃表实现，根据成员查找分值时，复杂度将为 O(logn)</strong> 。综上，为了让有序集合的分值查找和范围查找都尽可能快地执行，Redis 选择字典和跳跃表两种数据结构结合的方式</p>
<p>　跳表时间复杂度<img src="https://api2.mubu.com/v3/document_image/5b934ef8-c434-473d-88d0-faa17f1821e1-12259280.jpg" alt="img"></p>
<h5 id="数据库"><a href="# 数据库" class="headerlink" title="数据库"></a>数据库</h5><p>　Redis 把所有库信息都保存在 redis.h/redisServer 结构的 db 数组中，数组类型是 redis.h/redisDB，dbnum 决定着应该创建多少数据库中的 db，默认为 16，clients 维护着所有连接 Redis 的客户端<img src="https://api2.mubu.com/v3/document_image/79cb9883-2f79-4a5b-8a0f-60e0eebc74ab-12259280.jpg" alt="img"></p>
<p>切换库时，其实就是 redisClient.db 对 redisServer.db 数组的目标数据库指针的移动　<img src="https://api2.mubu.com/v3/document_image/81d85ea8-e660-4a79-b3fa-b4ffb356ee94-12259280.jpg" alt="img"></p>
<h6 id="存储过期时间"><a href="# 存储过期时间" class="headerlink" title="存储过期时间"></a>存储过期时间</h6><p>　redisDb 中有一个 expires 的字典数据结构保存所有键的过期时间，也称为过期字典。过期字典的值是一个 long long 类型的整数，保存了键所指向的数据库键的过期时间（毫秒精度的 Unix 时间戳）</p>
<p><img src="https://api2.mubu.com/v3/document_image/0089123b-1ace-428f-8d52-dd5d37c830be-12259280.jpg" alt="img"></p>
<h6 id="过期键删除策略"><a href="# 过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h6><p>　定时删除：设置键的过期时间时，创建定时器，过期时，定时器立刻执行键的删除。</p>
<p>　惰性删除：不着急删除过期键，每次获取时都会进行过期校验</p>
<p>　定期删除：隔一段时间，程序就对数据库检查，删除过期键</p>
<h6 id="删除策略的特点"><a href="# 删除策略的特点" class="headerlink" title="删除策略的特点"></a>删除策略的特点 </h6><p>　定时删除：<strong> 对内存友好，但对 CPU 不友好。</strong>过期键比较多时，删除会占用资源，特别是和删除当前任务无关的过期键，影响性能。<strong>Redis 定时器需要创建时间事件</strong>，时间事件底层由无序链表实现，查找复杂度为 O(N)，如果需要高效处理必然要创建大量的定时器，并不现实。</p>
<p>　惰性删除：<strong>对 CPU 友好，但对内存不友好 </strong>。不需要把时间浪费在非相关键的删除上。如果有非常多的过期键，这些键又恰好没有被访问到的话，那么它们永远不会被删除，除非用户手动执行 flushdb，我们甚至可以把<strong> 这种情况下看作是一种内存泄露 </strong>。当键非常多时，会导致内存泄漏，因为<strong> 只有用到时才会判断，删除</strong>。</p>
<p>　定期删除：<strong>定时删除占用太多 CPU 时间，影响响应时间，惰性删除浪费太多内存，有内存泄露的风险 </strong>。<font color="red"> 定期删除是一种折衷的方式</font>，隔一段时间执行一次，并限制删除操作执行的时长和频率减少对 CPU 的占用；定期删除还能减少庞大的过期键对内存的占用。</p>
<p>　<strong>难点是如何确定时长和频率，执行得太频繁或者执行时间太长，会退化为定时删除，执行得太少或者执行时间太短，会退化为惰性删除</strong>，因此，服务器必须根据情况，合理设置删除的执行时长和执行频率。</p>
<h5 id="redis 持久化"><a href="#redis 持久化" class="headerlink" title="redis 持久化"></a>redis 持久化</h5><p>　RDB 持久化：RDB 文件是经过压缩的二进制文件，可通过该文件还原成数据库状态</p>
<p>　AOF 持久化：采用日志的形式来记录每个写操作，并追加到文件中</p>
<h6 id="RDB 与 AOF 共存的载入情况"><a href="#RDB 与 AOF 共存的载入情况" class="headerlink" title="RDB 与 AOF 共存的载入情况"></a><strong>RDB 与 AOF 共存的载入情况 </strong></h6><p>　由于 AOF 文件的更新频率更高，因此开启 AOF 持久化功能后，启动时<strong> 优先加载 AOF 还原数据</strong>，只有在 AOF 处于关闭状态，才使用 RDB 文件恢复数据</p>
<h6 id="SAVE 和 BGSAVE 的区别"><a href="#SAVE 和 BGSAVE 的区别" class="headerlink" title="SAVE 和 BGSAVE 的区别"></a>SAVE 和 BGSAVE 的区别 </h6><p>　SAVE 会<strong> 阻塞 Redis 服务器进程 </strong>，直到 RDB 文件创建完毕为止，<strong> 阻塞期间，服务器不能处理任何命令请求。</strong></p>
<p>　<strong>BGSAVE 会 fork 出一个子进程 </strong>，由<strong> 子进程负责创建 RDB 文件，父进程继续处理命令请求</strong>。当子进程完成之后，向父进程发送信号</p>
<h6 id="服务器是如何根据 save 选项来自动执行 BGSAVE 的？"><a href="# 服务器是如何根据 save 选项来自动执行 BGSAVE 的？" class="headerlink" title="服务器是如何根据 save 选项来自动执行 BGSAVE 的？"></a>服务器是如何根据 save 选项来自动执行 BGSAVE 的？</h6><p>　主要是根据<strong>dirty 计数器和 lastsave 属性，</strong>dirty 计数器记录距离上次成功执行 SAVE 或 BGSAVE 后数据库被修改了几次，lastsave 是一个 UNIX 时间戳，记录上次成功执行 SAVE 或 BGSAVE 的时间</p>
<h6 id="AOF 文件的载入与数据还原"><a href="#AOF 文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h6><ul>
<li>1. 创建一个没有网络连接的伪客户端。因为 Redis 命令只能在客户端上下文中执行，并且 AOF 文件在本地而不是网络</li>
<li>2. 解析 AOF 文件并取出一条写命令</li>
<li>3. 使用 <strong> 伪客户端 </strong> 执行被读出的写命令</li>
<li>4. 持续执行 2 和 3，直到所有写命令都已经执行完毕<img src="https://api2.mubu.com/v3/document_image/135f9792-2877-463e-9054-7cb6d49022f1-12259280.jpg" alt="img"></li>
</ul>
<h6 id="AOF 重写"><a href="#AOF 重写" class="headerlink" title="AOF 重写"></a>AOF 重写 </h6><p>　<strong> 因为 AOF 持久化会将所有的写命令都记录，所以会有冗余情况 </strong>，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。所以需要一种<strong> 瘦身机制确保 AOF 里存的都是必不可少的精华</strong></p>
<p>　Redis 提供 AOF 文件重写功能，让服务器创建一个新的 AOF 文件，替代现有的 AOF 文件，减少冗余命令。<strong>虽然名字叫 AOF 重写，但是在新的 AOF 文件的重写过程中，不会读取旧 AOF 文件，而是通过读取数据库状态来实现的 </strong>。首先<strong> 从数据库中读取键现在的值，然后用一条命令记录键值对</strong>，代替之前记录的多条命令。</p>
<p>　比如 RPUSH  list “A”  RPUSH list  “B” RPUSH  list “C” RPUSH  list “D” RPUSH list  “E” ，如果没有 AOF 重写，AOF 文件要保存 5 条命令，<strong>如果服务器想要用尽量少的命令来记录 list 的状态，最简单高效的办法不是去读取和分析 AOF 文件的内容，而是直接从数据库中读取 list 键的值</strong>，然后用一条 RPUSH list “A” “B” “C” “D” “E”代替 5 条命令</p>
<h6 id="AOF 重写过程"><a href="#AOF 重写过程" class="headerlink" title="AOF 重写过程"></a>AOF 重写过程 </h6><p>　AOF 重写的过程中会有<strong> 大量的写入操作 </strong>，为了<strong> 避免 Redis 服务器长时间的阻塞 </strong>，重写工作将被<strong> 放到子进程中进行 </strong>。这样<strong> 父进程仍然可继续处理请求</strong></p>
<p>　子进程在执行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致当前数据库状态与重写后的 AOF 文件保存状态不一致。为解决这个问题，<strong>设置了 AOF 重写缓冲区</strong></p>
<p>　当重写子进程创建后，Redis 服务器执行完写命令就会将其写入 AOF 缓冲区和 AOF 重写缓冲区，子进程执行重写期间，服务器进程要执行 3 个工作：</p>
<ul>
<li><p>执行客户端发来的命令。</p>
</li>
<li><p>将执行后的写命令追加到 AOF 缓冲区</p>
</li>
<li><p>将执行后的写命令追加到 AOF 重写缓冲区<img src="https://api2.mubu.com/v3/document_image/f7d5cbc6-ea87-4ae1-8a78-f74561e57503-12259280.jpg" alt="img"></p>
</li>
</ul>
<p>　当子进程完成重写后，<strong>会向父进程发送一个信号 </strong>，父进程接收并调用信号处理函数，将<strong> 重写缓冲区的所有内容写到新 AOF 文件中，原地覆盖现有的 AOF 文件 </strong>。因此整个 AOF 文件重写的过程中，<strong> 只有信号处理函数执行时，才会阻塞</strong>，将性能损耗降到最低。</p>
<h5 id="主从复制"><a href="# 主从复制" class="headerlink" title="主从复制"></a>主从复制 </h5><p>　通过 SLAVEOF 命令或配置文件中设置 slaveof 选项设置主从，Redis 的复制功能分为<strong> 同步 </strong> 和<strong>命令传播 </strong> 俩操作：</p>
<ul>
<li>同步用于把 slave 的数据库状态更新至 master 的数据库状态</li>
<li>命令传播是在 master 的数据库状态被修改时，导致主从数据库状态不一致，让主从回到一致的过程</li>
</ul>
<h6 id="同步和命令传播过程"><a href="# 同步和命令传播过程" class="headerlink" title="同步和命令传播过程"></a>　同步和命令传播过程 </h6><h6 id="同步"><a href="# 同步" class="headerlink" title="同步"></a> 同步</h6><ul>
<li>slave 向主发送 SYNC 命令。</li>
<li>master 接收并执行 BGSAVE，后台生成 RDB 文件，并用 <strong> 一个缓冲区记录现在开始执行的所有写命令</strong>。</li>
<li>BGSAVE 执行完毕时，master 将 RDB 文件发给 slave，slave 接收并载入，更新数据库状态。</li>
<li>master<strong>将其记录在缓冲区的所有写命令发给 slave</strong>，slave 执行写命令<img src="https://api2.mubu.com/v3/document_image/0502a38d-b4a5-42a7-bde5-666c372ded94-12259280.jpg" alt="img"></li>
</ul>
<h6 id="命令传播"><a href="# 命令传播" class="headerlink" title="命令传播"></a>　命令传播</h6><p>　　当 master 发生写操作时，主从同步需要通过命令传播，master 将写命令发送给 slave，slave 接收并执行相同的写命令</p>
<h5 id="一次完整的主从复制过程"><a href="# 一次完整的主从复制过程" class="headerlink" title="一次完整的主从复制过程"></a>一次完整的主从复制过程 </h5><p>　一次完整的复制过程可以分为<strong> 设置主服务器的地址和端口、建立套接字连接、发送 PING 命令、身份验证、发送端口信息、同步、命令传播</strong></p>
<ul>
<li>1. 设置主服务器的地址和端口：当客户端向 slave 发送 slaveof 127.0.0.1:6379 时，slave 要将客户端给定的 ip 和端口号都保存后发送 OK。这是一个异步命令，所以复制工作在回复 OK 后再执行。</li>
<li>2. 创建连向 master 的套接字连接，如果成功，slave 会给它关联一个处理复制工作的文件事件处理器（负责接收 RDB，传播的命令等）。主从成功连接后，master 会创建从服务器的客户端状态，<strong>将 slave 看做是一个客户端来看待</strong><img src="https://api2.mubu.com/v3/document_image/00a7b512-8ce2-4aab-a504-12e4d5887aa6-12259280.jpg" alt="img"></li>
<li>发送 PING 命令：slave 在套接字连接后做的第一个工作就是发送 PING 命令，<strong>检查套接字读写状态是否正常</strong>；主服务器能否正常处理命令请求。而主服务器会根据网络状态、能够处理给出对应回复。一旦回复超时或返回错误，从服务器就会断开并重连主服务器。</li>
<li>身份验证：收到 <strong>master 的 pong 回复</strong> 之后，检查从服务器是否设置<strong>masterauth，如果设置则进行身份验证</strong></li>
<li>发送端口信息：slave<strong>向 master 发送自己监听的端口号</strong>，master 保存这个端口号，也就是 12345</li>
<li>同步：从服务器发送 PSYNC 命令，主从互相成为对方的客户端，都能够执行命令并回复，执行同步操作，看是完整重同步还是部分重同步。</li>
<li>命令传播：完成同步后，进入该阶段，主服务器将写命令发送给从服务器，从服务器接收并执行</li>
</ul>
<h6 id="心跳机制"><a href="# 心跳机制" class="headerlink" title="心跳机制"></a>心跳机制 </h6><p>　在命令传播阶段，从服务器默认 1 秒一次发送 REPLCONF ACK <replication_offset> 命令给主服务器，<strong>replication_offset 是复制偏移量</strong>。这么做有 3 个作用：</replication_offset></p>
<ul>
<li>检测主从网络状态：若主服务器超过一秒没收到从服务器的 REPLCONF ACK 则表示连接有问题。</li>
<li>辅助实现 min-slave 选项：min-slaves-to-write 3 min-slaves-max-lag 10 表示从服务器数量少于 3 或 3 个从服务器延迟大于等于 10s 时，主服务器拒绝写命令。</li>
<li>检测命令丢失：如果 master 传播给 slave 的写命令在半路丢失，那么 slave 向 master 发送 REPLCONF ACK 时，master 发现 slave 当前的复制偏移量少于自己的复制偏移量，就从积压缓冲区里找到并补发。<img src="https://api2.mubu.com/v3/document_image/799f8eb4-35cb-453c-b135-d8cb51f5a0a3-12259280.jpg" alt="img"></li>
</ul>
<p>如图所示，这时会将复制缓冲区里面复制偏移量为 201-233 的命令重发</p>
<h5 id="Sentinel 机制"><a href="#Sentinel 机制" class="headerlink" title="Sentinel 机制"></a><strong>Sentinel 机制 </strong></h5><p>　Sentinel（哨兵）是 Redis 的<strong> 高可用性 </strong> 的解决方案，由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器以及属下的所有从服务器。当主服务器下线时，自动将下线的某个主服务器属下的某个从服务器升级为新的主服务器。从而实现故障转移，<strong>当原来的主服务器重新上线时，会被降级为从服务器。</strong></p>
<h6 id="Sentinel 系统对主服务器执行故障转移的过程"><a href="#Sentinel 系统对主服务器执行故障转移的过程" class="headerlink" title="Sentinel 系统对主服务器执行故障转移的过程"></a>　Sentinel 系统对主服务器执行故障转移的过程</h6><ul>
<li>检测 <strong> 主观下线 </strong> 状态：Sentinel 默认每秒与创建命令连接的实例 <strong> 发送 PING 命令 </strong>，通过回复判断是否在线。由于每个 Sentinel 中的<strong> 主观下线时间配置都可以不同，所有有可能某个 Sentinel 判断主观下线时，另一个 Sentinel 认为在线状态</strong></li>
<li>检查 <strong> 客观下线 </strong> 状态：当 Sentinel 判断主服务器为主观下线时，还会向其他 Sentinel 询问，得到足量数据已下线判断后，就会判定服务器为客观下线，并执行故障转移。</li>
<li><strong>选举领头 Sentinel</strong><ul>
<li>当主服务器被判断为客观下线时，sentinel 会协商选举领头 sentinel，并由领头 sentinel 对下线主服务器执行故障转移操作</li>
<li>当 SENTINEL is-master-down-by-addr 命令 <strong> 已经确认主服务器客观下线时 </strong>，Sentinel 还会再发送带有选举性质的命令，<strong> 并且带上自己的运行 ID</strong>。如果接收命令的 Sentinel 还没设置局部领头时，就会将这个运行 ID 作为自己的 Multi Bulk 回复参数。根据回复参数来判断多少 sentinel 将自己设置为局部领头。可能根据网络延迟，有的 Sentinel 命令比其他 Sentinel 都先到达，并且胜出（必须有半数以上的票），那么就由它负责故障转移。一次选举没有产生，一段时间后再次选举，直到选出</li>
</ul>
</li>
</ul>
<h5 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h5><p>　出现的原因：主从复制不能实现高可用、业务需要更高的 QPS，而主从复制中单机的 QPS 可能无法满足业务需求</p>
<p>​    节点取余方式：对每个数据进行 hash 运算之后，与节点数进行取余运算，根据余数不同保存在不同的节点上，<strong>优点是配置简单，缺点是数据节点伸缩时，导致数据迁移</strong></p>
<p>　一致性哈希方式：将所有的数据当做一个哈希环，哈希环中的数据范围是 0-2＾32。然后为每一个数据节点分配一个哈希值，<strong>这个节点就负责保存这个范围内的数据 </strong>。对<strong> 每一个 key 进行 hash 运算，被哈希后的结果在哪个 node 的范围内，则 <font color="red"> 按顺时针去找最近的节点 </font>&gt;，这个 key 将会被保存在这个节点上。</strong> 优点是 <font color="red"> 节点伸缩时，只影响邻近节点</font></p>
<p><img src="https://api2.mubu.com/v3/document_image/42cee358-df0c-4e1d-b0f1-655e92f976d1-12259280.jpg" alt="img">**</p>
<h6 id="分配槽"><a href="# 分配槽" class="headerlink" title="分配槽"></a>分配槽 </h6><p>　1. 每个节点通过通信都会共享 Redis Cluster 中<strong> 槽和集群中对应节点的关系</strong></p>
<p>　2. 客户端向 Redis Cluster 的任意节点发送命令，接收命令的节点会根据 CRC16 规则进行<strong>hash 运算与 16383 取余</strong>，计算自己的槽和对应节点 </p>
<p>　3. 如果保存数据的槽被分配给当前节点，则去槽中执行命令，并把命令执行结果返回给客户端 </p>
<p>　4. 如果保存数据的槽不在当前节点的管理范围内，则 <strong> 向客户端返回 moved 重定向异常</strong> </p>
<p>　5. 客户端接收到节点返回的结果，如果是 moved 异常，则 <strong> 从 moved 异常中获取目标节点的信息</strong> </p>
<p>　6. 客户端向目标节点发送命令，获取命令执行结果<img src="https://api2.mubu.com/v3/document_image/ea429ae5-bc25-492b-b584-303d4c5c7e76-12259280.jpg" alt="img"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/20/JVM%E5%AE%9E%E6%88%98/JVM%E5%AE%9E%E6%88%98/" rel="prev" title="JVM 实战">
      <i class="fa fa-chevron-left"></i> JVM 实战
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/09/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/" rel="next" title="Java 基础">
      Java 基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }

</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%20%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">Redis 中的数据结构 </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text"> 字符串</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.</span> <span class="nav-text">字符串总结 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text"> 链表 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">1.4.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">跳表 </span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">2.1.</span> <span class="nav-text">存储过期时间</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.</span> <span class="nav-text">过期键删除策略</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">删除策略的特点 </span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis%20%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">redis 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#RDB%20%E4%B8%8E%20AOF%20%E5%85%B1%E5%AD%98%E7%9A%84%E8%BD%BD%E5%85%A5%E6%83%85%E5%86%B5"><span class="nav-number">3.1.</span> <span class="nav-text">RDB 与 AOF 共存的载入情况 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SAVE%20%E5%92%8C%20BGSAVE%20%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.</span> <span class="nav-text">SAVE 和 BGSAVE 的区别 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%20save%20%E9%80%89%E9%A1%B9%E6%9D%A5%E8%87%AA%E5%8A%A8%E6%89%A7%E8%A1%8C%20BGSAVE%20%E7%9A%84%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">服务器是如何根据 save 选项来自动执行 BGSAVE 的？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF%20%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%BD%E5%85%A5%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BF%98%E5%8E%9F"><span class="nav-number">3.4.</span> <span class="nav-text">AOF 文件的载入与数据还原</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF%20%E9%87%8D%E5%86%99"><span class="nav-number">3.5.</span> <span class="nav-text">AOF 重写 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF%20%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B"><span class="nav-number">3.6.</span> <span class="nav-text">AOF 重写过程 </span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">主从复制 </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">　同步和命令传播过程 </span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">4.2.</span> <span class="nav-text"> 同步</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="nav-number">4.3.</span> <span class="nav-text">　命令传播</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">一次完整的主从复制过程 </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.</span> <span class="nav-text">心跳机制 </span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sentinel%20%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">Sentinel 机制 </span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Sentinel%20%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8C%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">　Sentinel 系统对主服务器执行故障转移的过程</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis-Cluster"><span class="nav-number">7.</span> <span class="nav-text">Redis Cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E6%A7%BD"><span class="nav-number">7.1.</span> <span class="nav-text">分配槽 </span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dreamer-shan"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Dreamer-shan</p>
  <div class="site-description" itemprop="description">吃西瓜不吐西瓜皮，不吃葡萄倒吐葡萄皮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Dreamer-shan" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Dreamer-shan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/1713944558@qq.com" title="E-Mail → 1713944558@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
              <div id="music163player">
                  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1827559941&auto=1&height=66"></iframe>
              </div>
  </aside>

  <div id="sidebar-dimmer"></div>



      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dreamer-shan</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">83k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:16</span>
</div>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
